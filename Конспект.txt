/*Неплохо бы разбить его по темам, кроме просто такого цельного пункта. Херня эта вся классификация по пунктам с цифрами. Стоит сделать подпункты. А ещё, как мне кажется, неплохо бы переделать внешнее оформление и вообще, написать бы цветовую схему и синтаксис для конспекта, а то сложно воспринимать его в монолите. Ещё можно было бы сгруппировать каждую тему по блокам: термины, плюсы|минусы и т.д.*/

Конспект

		1. Что такое языки программирования и какие они бывают
ОС  --  операционная система

ЯП  --  язык программирования

Интерпретатор  --  программа, которая сразу пытается выполнить код программы, по мере его поступления
Компилятор  --  программа, которая пытается преобразовать код к исполняемому файлу

Интерпретируемый ЯП  --  ЯП, код которого считывается строчка за строчкой и передаётся по строчке интерпретатору. Интерпретатор пытается сразу же выполнить код

Интерактивный режим  --  процесс написания кода, когда человек пишет код и он сразу же выполняется

Компилируемый ЯП  -- ЯП, код которого заранее анализируется компилятором и преобразуется в код, понятный машине

Плюсы и минусы Интерпретируемых ЯП-ов:
	+++
1. Возможность работы в интерактивном режиме
2. Возможность выполнения кода кусками
3. Кросс-платформенность
4. Рефлексия
5. Динамическая типизация
6. Меньший размер исполняемых файлов
7. Динамические области видимости

	---
1. Медленная скорость работы
2. Кросс-платформенность

Плюсы и минусы Компилируемых ЯП-ов:
	+++
1. Скорость
2. Контроль
3. Управление памятью
4. Управление процессором
5. Платформо-зависимость

	---
1. Платформо-зависимость
2. Сложность отладки
3. Компиляция

Кросс-платформенность  --  возможность выполнения кода на разных операционных системах. Например Linux и Windows

Платформо-зависимость  --  невозможность выполнения кода на разных платформах

Рефлексия  --  самоанализ

Исполняемые файлы  --  файлы, код которых умеет выполнять операционная система. В windows это файлы с расширением .exe

	Типизация языков
1. динамическая/статическая
2. явная/неявная
3. сильная/слабая

Динамическая типизация  --  тип переменной определяется при выполнении программы
Статическая типизация  --  тип переменной определяется на этапе компиляции программы

Явная типизация  --  при объявлении переменной необходимо указывать её тип
Неявная типизация  --  при объявлении переменной не нужно указывать её тип

Сильная типизация  --  нельзя производить операции в выражениях с данными различных типов
Слабая типизация  --  можно производить операции в выражениях с данными различных типов


Python  --  обладает сильной неявной динамической типизацией


	Стандартная библиотека python
Стандартная библиотека python  --  это набор всех подключаемых модулей, которые поставляются вместе с интерпретатором

Модуль  --  функционально законченный фрагмент программы, оформленный в виде отдельного файла с исходным кодом или поименованной непрерывной её части

Основные модули:
sys, os, math, time


	IDE и редакторы кода
IDE  --  Integrated development environment(интегрированная среда разработки)

IDE  --  приложение, помогающее разработчику писать код, обладающее полезными функциями. Например анализ кода, подсветка синтаксиса, подсветка ошибок, поиск, возможность работы с проектами и т.д. Очень мощный инструмент

Редактор кода  --  приложение, позволяющее разработчику писать код. Обладает много меньшим набором полезных функций. В основном это подсветка синтаксиса

Основные IDE для python:
PyCharm, Visual Studio, Spyder, Eclipse

Основные редакторы кода для python:
Notepad++, Vim, Sublime Text 3


	Работа из консоли
ПО  --  программное обеспечение

Консоль  --  Интерфейс пользователя, окно для вывода системных сообщений и приёма команд
Консоль  --  ПО, реализующее текстовый интерфейс пользователя.



Аргументы командной строки  --  строки, передаваемые после основной команды при вызове команды разделённые пробелами

Чтобы открыть консоль нужно в строку поиска ввести cmd


Основные команды консоли:
help, cd, cls, md

help  --  если не передать аргументов, выводит базовую подсказку. Если передать аргумент, то выводит подробную информацию о нём

cd  --  переход в каталог, указанный аргументом. Можно указать, как абсолютный, так и относительный путь

cls  --  очищает консоль

md  --  создаёт каталог, указанный относительным или абсолютным путём в качестве аргумента



cls (clear screen)
cd = chdir (change directory)
md = mkdir (make directory)

Чтобы запустить программу на языке python из консоли нужно написать python и в качестве аргументов передать абсолютный или относительный путь к файлы. Можно передать, как в двойных кавычках, так и без

Чтобы войти в интерактивный режим нужно прописать python без аргументов. Чтобы выйти из него необходимо прописать exit()

Основы работы в интерактивном режиме

Если просто написать какое-либо значение, то python его выведет. Если передать выражение, то он выведет его результат

Если прописать функцию help и передать в качестве аргумента какую-то функцию, то он выведет всё, что о ней знает. Если вызвать функцию help без аргументов, то войдёшь в режим help. Ты сможешь сразу писать функцию и он выведет всё, что о ней знает. Чтобы выйти из неё надо просто прописать пустую строку

	
		2. Правила оформления кода
Код нужно оформлять, чтобы другие программисты могли легко прочитать программу и внедрится в проект. Также это необходимо для enterprise-а

Есть следующие стили написания кода:

camelStyle

Пример:
thisIsAnExample


PascalCase

Пример:
ThisIsAnExample


kebab-case

Пример:
this-is-an-example


snake_case

Пример
this_is_an_example


	PEP8
PEP8  --  сбор правил, утверждённый сообществом, объясняющий, как писать код, называть классы, перменные, сколько делать отступом и т.д. и т.п.

Просто слушайся PyCharm и всё будет хорошо. Их не надо заучивать


	Модули
Подходы к написанию кода:

1. Модульный подход  --  это организация программы как совокупности небольших независимых блоков, называемых модулями, структура и поведение которых подчиняются определённым правилам

2. Объектно-ориентированный подход  --  использует объектную декомпозицию, то есть поведение системы описывается в терминах взаимодействия объектов

3. Функциональный подход к управлению  --  это традиционное делегирование полномочий и определенной ответственности через функции, т. е. такие "подсистемы" организации, которые можно выделить по схожести проводимых работ

Парадигма программирования  --  это совокупность идей и понятий, определяющих стиль написания компьютерных программ


Некоторые парадигмы:
1. Императивное программирование
2. Декларативное программирование
3. Структурное программирование
4. Функциональное программирование
5. Логическое программирование
6. Объектно-ориентированное программирование
7. Структурное программирование
8. Процедурное программирование
9. Аппликативное программирование
10. Обобщённое программирование
11. Доказательное программирование
12. Порождающее программирование
13. Аспектно-ориентированное программирование
14. Агентно-ориентированное программирование
15. Рекурсия
16. Автоматное программирование
17. Событийно-ориентированное программирование
18. Компонентно-ориентированное программирование
19. Грамотное программирование


Иерархическая схема:
Смотри рисунок 0


	Библиотеки и фреймворки
Библиотека  --  сбор функций и модулей, призванный сократить написание однообразного кода. Пользуясь библиотекой в основном код пишешь всё ещё ты

Фреймворк  --  сбор функций, модулей и библиотек, призванный сократить написание однообразного кода. Пользуясь фреймворком в основном код берётся именно оттуда, а ты только добавляешь необходимые детали



		Ссылочная модель данных
Модель данных – это совокупность структур данных и операций их обработки

Инициализация  --  присваивание первоначального значения переменной

Python обладает ссылочной моделью данных. То есть каждая переменная это ссылка. Ссылка указывает на объект в памяти. Объект, в данном случае – это абстракция для представления данных, данные – это числа, списки, строки и т.п. При этом, под данными следует понимать как непосредственно сами объекты, так и отношения между ними. Каждый объект имеет три атрибута – это идентификатор, значение и тип. Идентификатор – это уникальный признак объекта, позволяющий отличать объекты друг от друга, а значение – непосредственно информация, хранящаяся в памяти, которой управляет интерпретатор

Когда мы пишем b = 5, то что происходит на уровне интерпретатора:
1. Создается целочисленный объект 5 (можно представить, что в этот момент создается ячейка и 5 кладется в эту ячейку);
2. Данный объект имеет некоторый идентификатор, значение: 5, и тип: целое число;
3. Посредством оператора связывания '=' создается ссылка между переменной 'b' и целочисленным объектом 5 (переменная 'b' ссылается на объект 5).




	Сборщик мусора
Когда на объект перестают указывать ссылки, его съедает garbage collector. Это удобно, т.к. не приходится самому помнить, что каждый созданный объект нужно уничтожить, иначе он так и будет плавать в памяти

	built-in типы
built-in типы  --  это типы, которые есть в любой программе изначально и не нужно подключать какие-то модули, чтобы ими пользоваться. built-in можно в данном случае перевести, как встроенные

В python существуют следующие built-in типы:

None Type (class NoneType)  --  тип для неопределённого значения переменной. Единственное значение: None
Numeric Type  --  числа
	Integral Type  --  типы, представляющиеся целыми числами:
		Boolean Type (class bool)  --  тип, обозначающий логическое значение. Есть два значения: True, False
		Integer Type (class int)  --  тип, обозначающий целое число
	Real Type (class float)  --  тип, обозначающий десятичные числа
	Complex Type (class complex)  --  тип, обозначающий комплексные числа
Sequence Type  --  типы, представляющие последовательности
	List Type (class list)  --  тип, обозначающий список элементов
	Tuple Type (class tuple)  --  тип, обозначающий неизменяемый список
	Range Type (class range)  --  тип, обозначающий арифметическую прогрессию
Text Sequence Type  --  типы, обозначающие строковые последовательности
	String Type (class str)  --  тип, обозначающий строковые последовательности(строки)
Binary Sequence Type  --  типы, обозначающие бинарные последовательности
	Bytes Type (class bytes)  -- тип, обозначающий последовательность битов
	Bytes Array Type (class bytearray)  --  тип, обозначающий массив битов
	MemoryView Type (class memoryview)  --  тип, не входящий в рамки нашего курса
Set Types  --  множества
	Set Type (class set)  --  тип, обозначающий множество элементов
	Frozen Set Type (class frozenset)  --  тип, обозначающий неизменяемое множество
Mapping Types  --  отображаемые типы
	Dictionary Type (class dict)  --  тип, представляющий словарь, хэш таблицу


Mutable  --  изменяемый
Immutable  --  неизменяемый

Mutable типы  --  это типы, которые могут изменится, не меняя идентификатор. То есть, если имя 'a' и имя 'b' указывали на один и тот же объект, то изменяя его по ссылке 'a' он изменится и по ссылке 'b'

Immutable типы  --  это типы, которые не изменяют сами себя


Immutable built-in типы:
целые числа (int), числа с плавающей точкой (float), комплексные числа (complex), логические переменные (bool), кортежи (tuple), строки (str) и неизменяемые множества (frozen set)

Mutable built-in типы:
списки (list), множества (set), словари (dict)


	Выражения
Выражение(expression)  --  совокупность переменных, констант, знаков операций, имен функций, скобок, которая может быть вычислена в соответствии с синтаксисом языка программирования. Результатом вычисления выражения является величина определенного типа

Когда python встречает выражения, то он начинает его вычислять. Если в него входят операции, то они выполняются в порядке, который определён для них. Функции вычисляются по мере необходимости

Разберём пример:
a = b + f(g(x) + 7 / 3 ** 4)
Как это воспримет python:
	Как он видит:
	1. =
	2. b
	3. +
	4. f(...)
	5. g(...)
	6. x
	7. +
	8. /
	9. **

	Как он выполнит:
	1. b
	2. x
	3. g(...)
	4. **
	5. /
	6. +
	7. f(...)
	8. +
	9. =


	Полезные функции
print(a)  --  выводит a, где a  --  выражение
input()  --  возвращает строку, считанную с клавиатуры
id(a)  --  возвращает идентификатор объекта, на который указывает имя 'a'
type(a)  --  возвращает тип объекта, с которым связано имя 'a'
len(a)  --  возвращает длину объекта, на который ссылается имя 'a'



	Приведение типов
Типы, это данные. А следовательно можно один тип преобразовать к другому. Например была у тебя валюта в евро, а стала в рублях. А затем ты купила пылесос. Это называется преведением типов

В общем виде:
класс(объект, ...)

Например, когда мы пишем int(input()), происходит следующее:
1. Пользователь вводит строку
2. Строка приводится к типу int


		3. Числовые типы
Атрибуты/поля/свойства класса  --  переменные, которые хранит каждый объект. Могут быть уникальны для каждого(например значения) и не привязанные к объекту (например значение числа pi)

Классовые функции  --  функции, прописанные в самом классе. Обычно они являются уникальными для каждого класса

Если у классовой функции в качестве аргумента написано self, / , то значит, что она применятся к самому объекту без аргументов

Структура использования атрибутов:
объект/класс.атрибут

аргумент/параметр функции  --  то, что передаётся в скобках

ключевой/именованный аргумент/параметр  --  параметр, передающийся только по его имени

Структура использования функции(я здесь немножко вру, но это мы разберём более подробно, когда перейдём к функциям):
имя_функции(обязательный_аргумент1, обязательный_аргумент2, [необязательный_аргумент 1[, необязательынй_аргумент 2...]], именованый_аргумент1=значение1, именованый_аргумент2=значение2)

Примечание
Когда пишут аргументы функции, если часть из них заключена в скобки, то значит, что они необязательны

Функция может быть использована и без аргументов:
print()


	Класс int
Класс int хранит в себе число в десятичной системе счисления. К нему применимы все арифметические операторы. К нему можно привести тип str

В общем виде приведение типа str к типу int выглядит следующим образом:
int(x[, base])  --  x строка, base основание системы счисления. То есть он пытается преобразовать строку из системы счисления с основанием base к десятичной системе счисления. В случае неудачи  --  ошибка. По умолчанию base = 10

Создание объекта int на основании объекта int:
int([x])  --  x класс int. По умолчанию x = 0

К классу int применима функция abs(x)


Классовые функции:
as_integer_ratio(self, /)  --  возвращает пару целых чисел, дробь из которых равна данному числу
bit_length(self, /)  --  Возвращает сколько битов необходимо, чтобы записать данное число в двоичной системе счисления
from_bytes(bytes, byteorder, *, signed=False)  --  собирает число из байтов


	Класс float
Класс float хранит в себе дробное число в десятичной форме. К нему применимы все арифметические операторы. К нему можно привести тип str

В общем виде приведение типа str к типу float выглядит следующим образом
float(x)  --  x строка

Создание объекта float на основании типа float:
float([x])  --  x класс float. По умолчанию x = 0.0

Создание объекта int на основании объекта float:
int(x)  --  x объект класса float. При приведении дробная часть отбрасывается


Классовые функции:
as_integer_ratio(self, /)  --  возвращает пару целых чисел, дробь из которых равна данному числу
conjugate(self, /)  --  возвращает комлексно-сопряжённое данному числу
hex(self, /)  --  переводит число в 16-ричную систему счисления
is_integer(self, /)  --  возвращает правду, если число является целочисленным
fromhex(string, /)  --  string строка, содержащая дробное число в 16-ричной системе счисления

	Класс complex
Класс complex представляет комплексные дробные и целые числа


Создание объекта complex:
complex([x[, y]])  --  x, y целые или дробные числа. По умолчанию x, y = 0. y - комплексная часть числа, x - действительная часть числа

Атрибуты:
real, imag

Классовые функции:
conjugate()  --  возвращает комплексно сопряжённое данному числу

		
		4. Логический тип
	Класс bool
Класс bool представляет правду или ложь. Является подклассом класса int


Создание объекта класса bool:
bool(x)  --  x объект класса int. Возвращает ложь, если x равен нулю, иначе правда
bool(x)  --  x объект класса float. Возвращает ложь, если x равен нулю, иначе правда
bool(x)  --  x объект класса complex. Возвращает ложь, если действительная и мнимая часть x равны нулю, иначе правда
bool(x)  --  x объект класса str. Возвращает ложь, если x пустая строка, иначе правда

Принцип следующий: Возвращает правду, если объект является правдой. То есть оно пытается привести объект к классу bool и смотрит на результат

К классу bool могут быть применены все арифметические операции


		Операторы
Оператор  --  инструкция или оператор — наименьшая автономная часть языка программирования; команда или набор команд

Операнды  --  аргумент операции; данные, которые обрабатываются командой/оператором


Унарные операторы  --  операторы, принимающие 1 операнд
Бинарные операторы  --  операторы, принимающие 2 операнда
Тернарные операторы  --  операторы, принимающие 3 операнда

Операторы в python делятся на:
1. Арифметические операторы
2. Операторы сравнения (реляционные)
3. Операторы присваивания
4. Побитовые операторы
5. Логические операторы
6. Операторы членства (Membership operators)
7. Операторы тождественности (Identity operators)

	Арифметические операторы
Унарные: "+", "-"
	"+"  --  комплиментарный оператор. Его действие выходит за рамки курса
	"-"  --  комплиментарный оператор. От него тебе нужно только знать, что когда ты пишешь -5, "-" это комплиментарный оператор
Бинарные: "+", "-", "*", "/", "%", "**", "//"
	Сложение "+"  --  возвращает сумму двух операндов
	Вычитание "-"  --  возвращает разность двух операндов
	Умножение "*"  --  возвращает произведение двух операндов
	Деление "/"  --  возвращает частное двух операндов, тип всегда float
	Деление по модулю "%"  --  возвращает остаток от деления двух операторов
	Возведение в степень "**"  --  возвращает степень двух операндов
	Целочисленное деление "//"  --  возвращает целую часть частного, тип всегда int

	Операторы сравнения
Бинарные: "==", "!=", ">", "<", ">=", "<="
	Равно "=="  --  проверяет равны ли оба операнда. Если да, то условие становится истинным
	Не равно "!="  --  проверяет равны ли оба операнда. Если нет, то условие становится истинным
	Больше ">"  --  Проверяет больше ли значение левого операнда, чем значение правого. Если да, то условие становится истинным
	Меньше "<"  --  Проверяет меньше ли значение левого операнда, чем значение правого. Если да, то условие становится истинным
	Больше или равно ">="  --  Проверяет больше или равно значение левого операнда, чем значение правого. Если да, то условие становится истинным
	Меньше или равно "<="  --  Проверяет меньше или равно значение левого операнда, чем значение правого. Если да, то условие становится истинным

	Операторы присваивания
Бинарные: "=", "+=", "-=", "*=", "/=", "%=", "**=", "//="
	Оператор связывания "="  --  связывает имя с объектом
	"+="  --  добавить к левому операнду значение правого и запихнуть в левый операнд
	"-="  --  вычесть из левого операнда значение правого и запихнуть в левый операнд
	"*="  --  умножить значение левого операнда на значение правого и запихнуть в левый операнд
	"/="  --  разделить значение левого операнда на значение правого и запихнуть в левый операнд
	"%="  --  найти остаток от деления значения левого операнда на значение правого и запихнуть в левый операнд
	"**="  --  возвести  значение левого операнда в значение правого и запихнуть в левый операнд
	"//="  --  найти целую часть от деления левого операнда на правый и запихнуть в левый операнд

	Побитовые операторы
Основное отличие в том, что они переводят всё в двоичную систему счисления и работают уже в ней. То есть они применяются к каждым двум битам операндов

Унарные: "~"
	Инверсия "~"  --  таблица истинности: "0:1|1:0"
Бинарные: "&", "|", "^", "<<", ">>"
	Побитовое И "&"  --  таблица истинности "0,0:0|1,0:0|0,1:0|1,1:1"
	Побитовое ИЛИ "|"  --  таблица истинности "0,0:0|1,0:1|0,1:1|1,1:0"
	Побитовое исключающее ИЛИ, XOR "^"  --  таблица истинности "0,0:0|1,0:1|0,1:1|1,1:0"
	Побитовый сдвиг влево "<<"  --  дописывает к левому операнду в конец количество нулей, равное второму операнду
	Побитовый сдвиг вправо ">>"  --  стирает у левого операнда количество битов, равное левому операнду

	Логические операторы
Работают только с типом bool, если операнды другого типа, то они преводятся к этому типу

Унарные: "not"
	Не "not"  --  меняет правду на ложь и обратно
Бинарные: "and", "or"
	И "and"  --  возвращает правду, только если оба операнда правда, иначе ложь
	Или "or"  --  возвращает правду, если хотя бы один операнд правда, иначе ложь

	Операторы членства
Бинарные: "in"
	В "in"  --  возвращает правду, если правый операнд содержит левый, иначе ложь

Примечание:
Можно писать not in

	Операторы тождественности
Операторы тождественности сравнивают размещение двух объектов в памяти компьютера

Бинарные: "is"
	Является ли "is"  --  возвращает правду, если оба имени указывают на один и тот же объект. То есть сравнивают id операндов

Примечание:
Можно писать is not


	Таблица приоритетов

**
~ + -  (+, - унарные)  
* / % //
+ -  (+, - бинарные)
>> <<
&
^ |
<= < > >=
(<> только в python2) == !=
= %= /= //= -= += *= **=
is is not
in not in
not or and


		5. Ветвление потока программы
До этого момента все наши программы выглядели следующим образом
Смотри рисунок 2

Теперь мы добавим некоторого разнообразия и программы станут выглядеть следующим образом
Смотри рисунок 3

Чтобы отобразить условия есть оператор if. Его общая структура:
Смотри рисунок 4
if условие:
	инструкции
elif условие:
	инструкции
  .
  .
  .
else:
	инструкции

elif и else необязательны

Про отступ:
1. Уровень отступа может быть любым, но принято 4 пробела
2. Для отступа можно использовать, как табуляции(tab), так и пробелы
3. Python запрещает смешивать знаки истинной табуляции и пробелы, но большинство текстовых редактором и IDE автоматически переводит знаки табуляции в 4 пробела. PyCharm в частности
4. Желательно использовать 4 пробела, нежели табуляцию, если редактор кода не умеет пункта 3

	Тернарный оператор
В python существует единственный тернарный оператор. Он записывается следующим образом:
(если_условие_ложно, если_условие_истинно)[условие]

Также справедлива следующая запись:
значение if условие else значение


Это бывает удобно, например:
Есть переменная для хранения количества значений и мы хотим найти среднее арифметическое чисел, которые считаем. Тогда если будет 0, то нужно будет не найти значение, а вывести, что таких чисел нет:
summa = 0
amount = 0
код
код
код
print((summa / amount, "Не было таких чисел")[amount == 0])

Важно стараться рассмотреть все случаи. Например следующий код может зафакапиться:
/&py
x_cord = int(input())
y_cord = int(input())
quater = 0
if x_cord > 0 and y_cord > 0:
	quater = 'I'
elif x_cord < 0 and y_cord > 0:
	quater = 'II'
elif x_cord < 0 and y_cord < 0:
	quater = 'III'
elif x_cord > 0 and y_cord < 0:
	quater = 'IV'
else:
	print('НЕВОЗМОЖНО')
if quater != 0:
	print(f'Координатная четверть: {quater}')
&py/
Если хотя бы одно число равно нулю, то точка лежит на оси => не находиться в конкретной четверти
Смотри рисунок 5


		6. Циклы
	Цикл while
Цикл while  --  цикл пока

1. Он выполняет инструкции, пока условие верно
2. В процессе выполнения инструкций он НЕ смотрит на условие
3. Если не изменять инструкциями внутри цикла условие, то мы зациклимся навечно

Немножко терминов:
Смотри рисунок 6
Итерация  --  фактическое единичное выполнение тела цикла

Различие между телом цикла и итерацией:
Итерация  --  именно выполнение кода, а тело цикла  --  сам код


Они справедливы для любого цикла

	Комментарии
Чтобы оставить комментарий, нужно поставить # (знак решётки). Всё, что идёт после него в данной строке не обрабатывается интерпретатором

PEP8  --  отступ от кода 2 пробела, отступ после решётки 1 пробел

	Перенос строки
Если строка слишком длинная, то мы можем поставить \ (знак обратного слеша) и он продолжит читать следующую строку, как продолжение этой

Если мы на одной строке открываем скобки и не закрываем их, то интерпретатор будет читать следующие строки, как продолжение этой, пока не найдёт закрывающей скобки

Если мы хотим уместить несколько строк в одной, то можно поставить ; . После этого символа интерпретатор начинает читать всё как новую строку, если не было других аргументов для продолжения (например незакрытые скобки или кавычки)

PEP8  --  максимальная длина одной строки 79 символов
PEP8  --  если мы открыли скобки и разбили их содержимое на смысловые единицы, то их нужно начинать с одним отступом
print(длинная_очень-очень_длинная_до_невозможности_длинная_строка1,
      длинная_очень-очень_длинная_до_невозможности_длинная_строка2,
      длинная_очень-очень_длинная_до_невозможности_длинная_строка3
      длинная_очень-очень_длинная_до_невозможности_длинная_строка4)
PEP8  --  не принято ставить ; , лучше обойтись следующей строкой
	
	Условие призрак
Если мы используем цикл while, без специальных инструкций, то после него обязательно условие, заложенное для продолжение неверно. Оно и называется условием призраком

То есть если у нас есть:
while a >= 0:
	код
То к концу цикла a точно меньше 0 (a < 0)

Если тело цикла очень большое и сложно за раз охватить его полностью (что плохо и грамотный разработчик так не делает(запиши это и выдели)), то после цикла можно оставить комментарий про условие призрак


Если мы используем специальные инструкции выхода в цикле, то мы разрушаем призрака, т.к. появляется несколько вариантом, почему мог быть закончен цикл

	Цикл for
Цикл for  --  цикл для

1. Он выполняет инструкции, подставляя значение каждого элемента в объекте
2. Цикл for очень трудно зациклить
3. Можно делать цикл не для одной переменной, а для нескольких. Это возможно, только когда каждый объект можно распаковать
4. В цикл for можно запихнуть любой итерируемый объект, то есть объект, к которому можно применить функцию next()


Пример 1
for i in 1, 2, 3:
	инструкции

	Функция range
В python, чтобы не извращаться, как в примере 1 есть генератор арифметических прогрессий. Это функция range. Она вычисляет следующий элемент на основании предыдущего

Общая форма range:
range([start], stop[, step])  --  по умолчанию start = 0, step = 1

Основные моменты:
1. step можно задать и отрицательным, то есть пойти в обратную сторону
2. range работает по следующему принципу:
	1) Вернуть start
	2) Добавить к start значение step
	3) Если start < stop повторить, иначе закончить

То есть к концу нашего курса ты сможешь написать цикл for собственноручно и функцию range собственноручно


Циклы могут быть вложенными. Тогда их тело отделяется новым уровнем отступа

	Специальные инструкции для циклов
break, continue

Обычно их не используют без условий, потому что они меняют ход выполнения инструкций цикла и всё, что шло после них не выполняется

Поэтому в схемах я буду сразу рисовать с условиями

1. break
Досрочно заканчивает цикл и прекращает выполнение инструкций
Смотри рисунок 7

2. continue
Досрочно перейти к следующей итерации
Смотри рисунок 8

Основные моменты:
1. Весь код после этих операторов НЕ выполняется
2. Эти операторы обычно находятся в побочной ветке программы
3. Они применяются к ближайшему циклу, в случае вложенности

	Способы срочно покинуть цикл
Тебе нужно знать 3 таких способа:
1. break
Его ты уже знаешь

2. Вызвать ошибку/исключение(Exception)
Это можно сделать следующим образом:
raise название_ошибки

Это чуть более срочный способ покинуть цикл. После него, если ошибку не обработать, о чём мы поговорим позже, интерпретатор вывалит нам в консоль traceback, о чём мы тоже поговорим позже, и закончит выполнение программы

3. Использовать sys.exit()
Это классовая функция модуля sys. Чтобы её использовать необходимо подключить пространство имён sys:
import sys
После чего мы можем использовать функцию sys.exit()

Она посылает сигнал ОС снять все ресурсы на вычислительные процессы

Как ляпнул Тимофей Фёдорович Хирьянов, цитата: "Он говорит операционной системе: 'Операционная система, кильни меня пожалуйста'"

По срочности от самого несрочного к самому срочному:
1. break
2. Exception
3. sys.exit()

	Else в циклах
Обычно в ЯП-ах так не делают, но в python сделали:
Если цикл закончился по нормальной причине, а не из-за выше упомянутых причин, то выполнится блок else

Его структура выглядит так:
Цикл
else:
	код
Где цикл, термин введённый ранее

		7. Более подробно про некоторые полезные функции 1

print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=false)
принимает значение или значения и выводит их в file или поток. По умолчанию выводит в консоль
sep - разделитель, ставящийся между всеми значениями
end - то, что ставиться после всех значений, по умолчанию "\n"
flush мы разбирать не будем

Основные моменты:
1. Если мы не передадим print никаких параметров, то выведется просто end
2. Выходная строка формируется по следующему принципу:
	_repr_(value1) + sep + _repr_(value2) + sep + ... + _repr_(valuen) + end


Мы не будем подробно рассматривать ключевой параметр file, т.к. это выходит за рамки нашего курса

input([string])  --  принимает строку с консоли. Если string указан, то сначала выводит string, а затем считывает данные с консоли

id()  --  возвращает идентификатор, с которым связано имя или переданный объект
type(object) - возвращает тип объекта

ord(value) value - строка из одного символа. Возвращает численное значение символа
chr(i)  --  преобразует число в строку состоящую из одного символа, соответствующего данному индексу


len(object) возвращает параметр длина, если таковой указан в объекте. Пара примеров:
1. Не применимо к Numeric Type
2. Не применимо к None Type
3. Для класса str  --  возвращает длину строки
4. Для объектов-контейнеров  --  возвращает количество элементов внутри
5. Для последовательности возвращает её длину


range([start ,] stop[, step])  --  генератор арифметических прогрессий. Возвращает прогрессию, сгенерированную, начиная с start, с шагом step, пока член прогрессии < stop
По умолчанию start = 0, step = 1
range - итерируемый объект

	Функции для отладки
help(имя_функции/класса)  --  выводит подсказку об этой функции, этом классе
dir(имя_класса)  --  выводит абсолютно все функции, лежащие внутри этого класса

breakpoint  --  позволяет приостановить выполнение программы и перейти в режим отладки


	Математические функции
abs(x)  --  возвращает модуль числа
round(x)  --  округляет число по правилам округления
divmod(x, y)  --  возвращает одновременно остаток от деления и целую часть от деления
pow(base, exp[, mod])  --  возводит base в степень exp, если mod не указан и находит остаток от деления степени на mod, если mod указан. Эффективней, чем pow(base, exp) % mod


	Логарифмы
Найдёшь сама, это не программирование. Для полного понимая лучше удели час - полтора видео с канала Бориса Трушина и всё поймёшь. Если что-то будет непонятно  --  обращайся
1. https://www.youtube.com/watch?v=kDyRtDdxyDE   28 минут
2. https://www.youtube.com/watch?v=wc7-rm65ISw   21 минута
3. https://www.youtube.com/watch?v=NyJGkH2b54M   12 минут
4. https://www.youtube.com/watch?v=_skyZu5ARAs   16 минут

Всего 77 минут. 1 час, 17 минут

	Множества
Ты вроде всё записала


		8. Архитектура компьютера
	Десятичные числа
с.с.  --  система счисления

+  --  сложить
*  --  умножить
^  --  возвести в степень

Десятичные числа закодированы в двоичной с.с.

Экспонента  --  число, на степень которого умножается каждый 0 или 1 в двоичной записи числа

Эпсилион  --  относительная погрешность при определённой экспоненте; относительная погрешность в окрестности числа


Например 0110,1101  можно представить как 0 * 2^3 + 1 * 2^2 + 1 * 2^1 + 0 * 2^0 + 1 * 2^-1 + 1 * 2^-2 + 0 * 2^-3 + 1 * 2^-4

Число имеет фиксированную длину, поэтому для презентации более больших и более маленьких чисел мы начинаем с большей или меньшей экспонент

Некоторые особенности
1. Фиксированная запятая(никакого смещения):
0000,0000 (здесь экспонента = 3)

2. Плавающая запятая(экспонента представляет смещение относительно старших бит):
0000,0000  --  экспонента = 3
000,00000  --  экспонента = 2
00,000000  --  экспонента = 1
0,0000000  --  экспонента = 0

3. Нормализованный вид(неявная единица вначале. Обычно её не видно):
1 000,0000  --  экспонента = 3
1 00,00000  --  экспонента = 2
1 0,000000  --  экспонента = 1
1 ,0000000  --  экспонента = 0

Общий вид числа float80 в python:
sign_bit * 1 + exp_bit * 15 + 1 * normalized_bit + mantissa_bit * 53
Смотри рисунок 9

Из экспоненты вычитается 011111111111111, чтобы мы могли получать дробные числа. То есть чтобы экспонента была 0, биты под экспоненту должны выглядеть так: 011111111111111

Особенности:
1. Так как при больших значениях числа, требуется большая экспонента, то при увеличении кодируемого числа точность понижается и в какой-то момент может превысить 1 и даже стать 128. За этим нужно следить

	Как составляются пути
В ОС Windows в пути к каждому файлы или папке:
Название_диска:\Папка1\Папка2\...\Конечная_папка

Например:
C:\Users\User\Desktop

Путь к папке можно оканчивать \, это не повлияет на конечную папку

Если нам нужен файл, то в конце пути мы просто дописываем его полное название:
название.расширение

При этом в названии могут содержаться точки

Например 
C:\Users\User\Desktop\1.1.py

Расширения

У файлов, которые являются исполняемыми расширение .exe

Файлы для хранения и передачи картинок:
.jpeg, .jpg  --  картинка, поддерживающая большое разнообразие цветов
.png  --  картинка, поддерживающая прозрачные цвета
.gif  --  гифка

Драйвера:
.dll  --  тебе нужно знать, что это драйвера, не более

Драйвер  --  ПО для работы с подключаемыми устройствами


Как составляются URL адреса сайтов
URL – это адрес документа или файла. Аббревиатура URL составлена из Uniform Resource Locator, что в переводе означает "Единый указатель ресурсов"

Адрес состоит из:
1. протокола
2. доменного имени
3. url пути
Необязательно:
4. якоря
5. параметров

Протокол отделяется с помощью ://
Доменное имя и url путь отделяются /
Доменное имя внутри разделяется .
Url путь внутри разделяется /
Якорь отделяется #
Параметры передаются через ?
Параметры внутри разделяются &
Параметры начинаются с имени, затем равно и значение

В адресе не может быть пробелов. Все специальные символы кодируются определённым образом

Смотри рисунок 11


Мы рассмотрим два протокола:
HTTP — это протокол передачи гипертекста. Он применяется при обмене данными с серверов – подключенному к Интернету компьютеру пользователя по его запросу
FTP — протокол, назначение которого — передача документов с сервера на персональное устройство пользователя. FTP позволяет обмениваться документами любым компьютерам сети

http делится на http и https
Смотри рисунок 12

Доменное имя
Мы рассмотрим имена только первого и второго уровней, но не сомневайся есть и корневое имя и домены 3, 4, и 5 уровней

Справа налево назначаются уровни домена начиная с первого. Самый правый называется доменом верхнего уровня или верховным доменом

Например:
Смотри рисунок 13


	Литералы
Литерал  --  это константы, зарезервированные символы определённых типов данных

	Целочисленные литералы
1. Число
Например:
/&py
1
2
7
5
&py/

2. Двоичные числа  //Начинаются с 0b
Например:
/&py
0b101
0b110
0b1001
&py/

3. Восьмеричные числа  //Начинаются с 0o
Например:
/&py
0o73
0o123
0o77
&py/

4. Шестнадцатеричные числа  //Начинаются с 0x
Например:
/&py
0xaf3
0x0b
&py/

	Дробные литералы
1. Десятичные числа
Например:
/&py
32.094
1.909
.94
0.0
&py/

2. Десятичные нормализованные числа
Например:
/&py
5.6453e-43
1.5e2
&py/

	Комплексные литералы
1. Комплексные числа
Например:
/&py
5+3.14j
&py/

	Булевы литералы
1. Булевы числа
Например:
/&py
True
False
&py/

Это все булевы литералы

	Специальные литералы
1. None
Например:
/&py
None
&py/

Остальные литералы мы рассмотрим в этом блоке



		9. Структуры данных
Структура данных  --  это контейнер, который хранит данные в определенном макете. Этот "макет" позволяет структуре данных быть эффективной в некоторых операциях и неэффективной в других

Структура данных  --  программная единица, позволяющая хранить и обрабатывать множество однотипных и/или логически связанных данных в вычислительной технике. Для добавления, поиска, изменения и удаления данных структура данных предоставляет некоторый набор функций, составляющих её интерфейс

Коллекция  --  программный объект, содержащий в себе, тем или иным образом, набор значений одного или различных типов, и позволяющий обращаться к этим значениям


В Python существуют четыре встроенных структуры данных: список, кортеж, словарь и множество

Схема коллекций:
Смотри рисунок 14.1
Смотри рисунок 14.2

	Общие методы работы с коллекциями
Индексированность  --  каждый элемент коллекции имеет свой порядковый номер — индекс. Это позволяет обращаться к элементу по его порядковому индексу, проводить слайсинг (нарезку) — брать часть коллекции выбирая исходя из их индекса

Уникальность  --  каждый элемент коллекции может встречаться в ней только один раз. Это порождает требование неизменности используемых типов данных для каждого элемента, например, таким элементом не может быть список

Изменяемость коллекции  --  позволяет добавлять в коллекцию новых членов или удалять их после создания коллекции

/&py
# Зададим исходно список и словарь:
my_list = ['a', 'b', 'c', 'd', 'e', 'f']
my_dict = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}
&py/

1. Печать элементов коллекции с помощью функции print()

/&py
print(my_list)   # ['a', 'b', 'c', 'd', 'e', 'f']
print(my_dict)   # {'a': 1, 'c': 3, 'e': 5, 'f': 6, 'b': 2, 'd': 4}
&py/

Примечание:
Порядок элементов в неиндексированных коллекциях не сохраняется


2. Подсчёт количества членов коллекции с помощью функции len()

/&py
print(len(my_list)) # 6
print(len(my_dict)) # 6 - для словаря пара ключ-значение считаются одним элементом
print(len('ab c')) # 4 - для строки элементом является 1 символ
&py/

3. Проверка принадлежности элемента данной коллекции c помощью оператора in

x in s — вернет True, если элемент входит в коллекцию s и False — если не входит
Есть и вариант проверки не принадлежности: x not in s, где есть по сути, просто добавляется отрицание перед булевым значением предыдущего выражения

/&py
my_list = ['a', 'b', 'c', 'd', 'e', 'f']
print('a' in my_list)           # True
print('q' in my_list)           # False
print('a' not in my_list)       # False
print('q' not in my_list)       # True
&py/

Примечание:
Для словаря возможны варианты, понятные из кода ниже:

/&py
my_dict = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}
print('a' in my_dict)               # True - без указания метода поиск по ключам
print('a' in my_dict.keys())        # True - аналогично примеру выше
print('a' in my_dict.values())      # False - так как 'а' — ключ, не значение
print(1 in my_dict.values())        # True
&py/

Можно ли проверять пары? Можно!

/&py
print(('a',1) in my_dict.items())   # True
print(('a',2) in my_dict.items())   # False
&py/

Для строки можно искать не только один символ, но и подстроку:

/&py
print('ab' in 'abc')    # True
&py/


4. Обход всех элементов коллекции в цикле for in

В данном случае, в цикле будут последовательно перебираться элементы коллекции, пока не будут перебраны все из них

/&py
for elm in my_list:
    print(elm)
&py/

Примечание:
Порядок обработки элементов для не индексированных коллекций будет не тот, как при их создании
У прохода в цикле по словарю есть свои особенности:

/&py
for elm in my_dict:
 	# При таком обходе словаря, перебираются только ключи
	# равносильно for elm in my_dict.keys()
 	print(elm)

for elm in my_dict.values():
 	# При желании можно пройти только по значениям
 	print(elm)
&py/

Но чаще всего нужны пары ключ(key) — значение (value).

/&py
for key, value in my_dict.items():
	# Проход по .items() возвращает кортеж (ключ, значение), 
	# который присваивается кортежу переменных key, value
	print(key, value)
&py/

Примечание:
Возможная ошибка: Не меняй количество элементов коллекции в теле цикла во время итерации по этой же коллекции! — Это порождает не всегда очевидные на первый взгляд ошибки

Чтобы этого избежать подобных побочных эффектов, можно, например, итерировать копию коллекции:

/&py
for elm in list(my_list):
    	# Теперь можешь удалять и добавлять элементы в исходный список my_list,
    	# так как итерация идет по его копии
&py/


5. Функции min(), max(), sum()

Функции min(), max() — поиск минимального и максимального элемента соответственно — работают не только для числовых, но и для строковых значений
sum() — суммирование всех элементов, если они все числовые

/&py
print(min(my_list))               # a
print(sum(my_dict.values()))      # 21
&py/

6. Распаковка набора элементов
Переменная1, переменная2, переменная3, ..., переменнаяN = (элемент1, элемент2, ..., элементN)

Например:
/&py
a, b, c = 1, 2, 3
&py/
Это то же, что и
/&py
a = 1
b = 2
c = 3
&py/



	Общие методы для части коллекций

Ряд методов у коллекционных типов используется в более чем одной коллекции для решения задач одного типа
Смотри рисунок 15

.count() — метод подсчета определенных элементов для неуникальных коллекций (строка, список, кортеж), возвращает сколько раз элемент встречается в коллекции

/&py
my_list = [1, 2, 2, 2, 2, 3]
print(my_list.count(2))     # 4 экземпляра элемента равного 2
print(my_list.count(5))     # 0 - то есть такого элемента в коллекции нет
&py/


.index() — возвращает минимальный индекс переданного элемента для индексированных коллекций (строка, список, кортеж)

/&py
my_list = [1, 2, 2, 2, 2, 3]
print(my_list.index(2))  # первый элемент равный 2 находится по индексу 1 (индексация с нуля!)
print(my_list.index(5))  # ValueError: 5 is not in list - отсутствующий элемент выдаст ошибку!
&py/


.copy() — метод возвращает неглубокую (не рекурсивную) копию коллекции (список, словарь, оба типа множества)

/&py
my_set = {1, 2, 3}
my_set_2 = my_set.copy()
print(my_set_2 == my_set)  # True - коллекции равны - содержат одинаковые значения
print(my_set_2 is my_set)  # False - коллекции не идентичны - это разные объекты с разными id
&py/


.clear() — метод изменяемых коллекций (список, словарь, множество), удаляющий из коллекции все элементы и превращающий её в пустую коллекцию

/&py
my_set = {1, 2, 3}
print(my_set)  # {1, 2, 3}
my_set.clear()
print(my_set)  # set()
&py/


К индексированным коллекциям можно применять следующие операции

Особые методы сравнения множеств (set, frozenset)

set_a.isdisjoint(set_b) — истина, если set_a и set_b не имеют общих элементов.
set_b.issubset(set_a) — если все элементы множества set_b принадлежат множеству set_a, то множество set_b целиком входит в множество set_a и является его подмножеством (set_b — подмножество)
set_a.issuperset(set_b) — соответственно, если условие выше справедливо, то set_a — надмножество

/&py
set_a = {1, 2, 3}              
set_b = {2, 1}                  # порядок элементов не важен!
set_c = {4}
set_d = {1, 2, 3}

print(set_a.isdisjoint(set_c))  # True - нет общих элементов
print(set_b.issubset(set_a))    # True  - set_b целиком входит в set_a, значит set_b - подмножество
print(set_a.issuperset(set_b))  # True - set_b целиком входит в set_a, значит set_a - надмножество
&py/

При равенстве множеств они одновременно и подмножество и надмножество друг для друга
/&py
print(set_a.issuperset(set_d))  # True
print(set_a.issubset(set_d))    # True
&py/


	Конвертация одного типа коллекции в другой

В зависимости от стоящих задач, один тип коллекции можно конвертировать в другой тип коллекции. Для этого, как правило достаточно передать одну коллекцию в функцию создания другой

/&py
my_tuple = ('a', 'b', 'a')
my_list = list(my_tuple)
my_set = set(my_tuple)		        # теряем индексы и дубликаты элементов!
my_frozenset = frozenset(my_tuple)      # теряем индексы и дубликаты элементов!
print(my_list, my_set, my_frozenset)    # ['a', 'b', 'a'] {'a', 'b'} frozenset({'a', 'b'})
&py/

Обрати внимание, что при преобразовании одной коллекции в другую возможна потеря данных:

1. При преобразовании в множество теряются дублирующие элементы, так как множество содержит только уникальные элементы! Собственно, проверка на уникальность, обычно и является причиной использовать множество в задачах, где у нас есть в этом потребность
2. При конвертации индексированной коллекции в неиндексированную теряется информация о порядке элементов, а в некоторых случаев она может быть критически важной!
3. После конвертации в не изменяемый тип, мы больше не сможем менять элементы коллекции — удалять, изменять, добавлять новые. Это может привести к ошибкам в наших функциях обработки данных, если они были написаны для работы с изменяемыми коллекциями


Дополнительные детали:

Способом выше не получится создать словарь, так как он состоит из пар ключ: значение

Это ограничение можно обойти, создав словарь комбинируя ключи со значениями с использованием zip():

/&py
my_keys = ('a', 'b', 'c')
my_values = [1, 2]      # Если количество элементов разное - 
		        		# будет отработано пока хватает на пары - лишние отброшены

my_dict = dict(zip(my_keys, my_values))
print(my_dict)          # {'a': 1, 'b': 2}
&py/


Создаем строку из другой коллекции:

/&py
my_tuple = ('a', 'b', 'c')
my_str = ''.join(my_tuple)
print(my_str)           # abc
&py/

Возможная ошибка: Если твоя коллекция содержит изменяемые элементы (например список списков), то ее нельзя конвертировать в не изменяемую коллекцию, так как ее элементы могут быть только не изменяемыми!

/&py
my_list = [1, [2, 3], 4]
my_set = set(my_list)   # TypeError: unhashable type: 'list'
&py/

	Индексирование

1 Индексированные коллекции

Рассмотрим индексированные коллекции (их еще называют последовательности — sequences) — список (list), кортеж (tuple), строку (string).

Под индексированностью имеется ввиду, что элементы коллекции располагаются в определённом порядке, каждый элемент имеет свой индекс от 0 (то есть первый по счёту элемент имеет индекс не 1, а 0) до индекса на единицу меньшего длины коллекции (т.е. len(mycollection)-1).

2 Получение значения по индексу

Для всех индексированных коллекций можно получить значение элемента по его индексу в квадратных скобках. Причем, можно задавать отрицательный индекс, это значит, что будем находить элемент с конца считая обратном порядке.

При задании отрицательного индекса, последний элемент имеет индекс -1, предпоследний -2 и так далее до первого элемента индекс которого равен значению длины коллекции с отрицательным знаком, то есть (-len(mycollection).
элементы	a	b	c	d	e
индексы	0 (-5)	1 (-4)	2 (-3)	3 (-2)	4 (-1)
/&py
	my_str = "abcde"
	print(my_str[0]) 		# a - первый элемент
	print(my_str[-1])		# e - последний элемент 
	print(my_str[len(my_str)-1]) 	# e - так тоже можно взять последний элемент
	print(my_str[-2]) 		# d - предпоследний элемент
&py/

Наши коллекции могут иметь несколько уровней вложенности, как список списков в примере ниже. Для перехода на уровень глубже ставится вторая пара квадратных скобок и так далее.

/&py
my_2lvl_list = [[1, 2, 3], ['a', 'b', 'c']]
print(my_2lvl_list[0])      # [1, 2, 3] - первый элемент — первый вложенный список
print(my_2lvl_list[0][0])   # 1 — первый элемент первого вложенного списка
print(my_2lvl_list[1][-1])  # с — последний элемент второго вложенного списка
&py/

3 Изменение элемента списка по индексу

Поскольку кортежи и строки у нас неизменяемые коллекции, то по индексу мы можем только брать элементы, но не менять их:

/&py
my_tuple = (1, 2, 3, 4, 5)
print(my_tuple[0])	  # 1
my_tuple[0] = 100         # TypeError: 'tuple' object does not support item assignment
&py/

А вот для списка, если взятие элемента по индексу располагается в левой части выражения, а далее идёт оператор присваивания =, то мы задаём новое значение элементу с этим индексом.

/&py
my_list = [1, 2, 3, [4, 5]]
my_list[0] = 10
my_list[-1][0] = 40
print(my_list)      	# [10, 2, 3, [40, 5]]
&py/

Примечание: Для такого присвоения, элемент уже должен существовать в списке, нельзя таким образом добавить элемент на несуществующий индекс.

/&py
my_list = [1, 2, 3, 4, 5]
my_list[5] = 6      # IndexError: list assignment index out of range
&py/


	Срезы

1 Синтаксис среза

Очень часто, надо получить не один какой-то элемент, а некоторый их набор ограниченный определенными простыми правилами — например первые 5 или последние три, или каждый второй элемент — в таких задачах, вместо перебора в цикле намного удобнее использовать так называемый срез (slice, slicing).

Следует помнить, что взяв элемент по индексу или срезом (slice) мы не как не меняем исходную коллекцию, мы просто скопировали ее часть для дальнейшего использования (например добавления в другую коллекцию, вывода на печать, каких-то вычислений). Поскольку сама коллекция не меняется — это применимо как к изменяемым (список) так и к неизменяемым (строка, кортеж) последовательностям.

Синтаксис среза похож на таковой для индексации, но в квадратных скобках вместо одного значения указывается 2-3 через двоеточие:

my_collection[start:stop:step]  # старт, стоп и шаг

Особенности среза:

Отрицательные значения старта и стопа означают, что считать надо не с начала, а с конца коллекции.
Отрицательное значение шага — перебор ведём в обратном порядке справа налево.
Если не указан старт [:stop:step]— начинаем с самого края коллекции, то есть с первого элемента (включая его), если шаг положительный или с последнего (включая его), если шаг отрицательный (и соответственно перебор идет от конца к началу).
Если не указан стоп [start:: step] — идем до самого края коллекции, то есть до последнего элемента (включая его), если шаг положительный или до первого элемента (включая его), если шаг отрицательный (и соответственно перебор идет от конца к началу).
step = 1, то есть последовательный перебор слева направо указывать не обязательно — это значение шага по умолчанию. В таком случае достаточно указать [start:stop]
Можно сделать даже так [:] — это значит взять коллекцию целиком
ВАЖНО: При срезе, первый индекс входит в выборку, а второй нет!
То есть от старта включительно, до стопа, где стоп не включается в результат. Математически это можно было бы записать как [start, stop) или пояснить вот таким правилом:
[ <первый включаемый> : <первый НЕ включаемый> : <шаг> ]

Поэтому, например, mylist[::-1] не идентично mylist[:0:-1], так как в первом случае мы включим все элементы, а во втором дойдем до 0 индекса, но не включим его!

Примеры срезов в виде таблицы:

Смотри рисунок 16

Код примеров из таблицы
2. Именованные срезы

Чтобы избавится от «магических констант», особенно в случае, когда один и тот же срез надо применять многократно, можно задать константы с именованными срезами с пользованием специальной функции slice()()

Примечание: Nonе соответствует опущенному значению по-умолчанию. То есть [:2] становится slice(None, 2), а [1::2] становится slice(1, None, 2).

/&py
person = ('Alex', 'Smith', "May", 10, 1980)
NAME, BIRTHDAY = slice(None, 2), slice(2, None)       
	# задаем константам именованные срезы
        # данные константы в квадратных скобках заменятся соответствующими срезами
print(person[NAME])      # ('Alex', 'Smith')
print(person[BIRTHDAY])  # ('May', 10, 1980)

my_list = [1, 2, 3, 4, 5, 6, 7]
EVEN = slice(1, None, 2)
print(my_list[EVEN])     # [2, 4, 6]
&py/

3. Изменение списка срезом

Важный момент, на котором не всегда заостряется внимание — с помощью среза можно не только получать копию коллекции, но в случае списка можно также менять значения элементов, удалять и добавлять новые.

Проиллюстрируем это на примерах ниже:

Даже если хотим добавить один элемент, необходимо передавать итерируемый объект, иначе будет ошибка TypeError: can only assign an iterable

/&py
my_list = [1, 2, 3, 4, 5]
# my_list[1:2] = 20     # TypeError: can only assign an iterable
my_list[1:2] = [20]     # Вот теперь все работает
print(my_list)          # [1, 20, 3, 4, 5]
&py/

Для вставки одиночных элементов можно использовать срез, код примеров есть ниже, но делать так не рекомендую, так как такой синтаксис хуже читать. Лучше использовать методы списка .append() и .insert():

Срез аналоги .append() и insert()
Можно менять части последовательности — это применение выглядит наиболее интересным, так как решает задачу просто и наглядно.

/&py
my_list = [1, 2, 3, 4, 5]
my_list[1:3] = [20, 30]
print(my_list)          # [1, 20, 30, 4, 5]
my_list[1:3] = [0]      # нет проблем заменить два элемента на один
print(my_list)          # [1, 0, 4, 5]
my_list[2:] = [40, 50, 60]   # или два элемента на три
print(my_list)               # [1, 0, 40, 50, 60]
&py/

Можно просто удалить часть последовательности

/&py
my_list = [1, 2, 3, 4, 5]
my_list[:2] = []    # или del my_list[:2]
print(my_list)      # [3, 4, 5]
&py/

4. Выход за границы индекса

Обращение по индексу по сути является частным случаем среза, когда мы обращаемся только к одному элементу, а не диапазону. Но есть очень важное отличие в обработке ситуации с отсутствующим элементом с искомым индексом.

Обращение к несуществующему индексу коллекции вызывает ошибку:

/&py
my_list = [1, 2, 3, 4, 5]
print(my_list[-10])       # IndexError: list index out of range
print(my_list[10])        # IndexError: list index out of range
&py/

А в случае выхода границ среза за границы коллекции никакой ошибки не происходит:

/&py
my_list = [1, 2, 3, 4, 5]
print(my_list[0:10])      # [1, 2, 3, 4, 5] — отработали в пределах коллекции
print(my_list[10:100])	  # [] - таких элементов нет — вернули пустую коллекцию
print(my_list[10:11])     # [] - проверяем 1 отсутствующий элемент - пустая коллекция, без ошибки
&py/


Примечание: Для тех случаев, когда функционала срезов недостаточно и требуются более сложные выборки, можно воспользоваться синтаксисом выражений-генераторов, рассмотрению которых посвещена 4 статья цикла.

	Сортировка элементов коллекции

Сортировка элементов коллекции важная и востребованная функция, постоянно встречающаяся в обычных задачах. Тут есть несколько особенностей, на которых не всегда заостряется внимание, но которые очень важны.

1 Функция sorted()

Мы может использовать функцию sorted() для вывода списка сортированных элементов любой коллекции для последующее обработки или вывода.

функция не меняет исходную коллекцию, а возвращает новый список из ее элементов;
не зависимо от типа исходной коллекции, вернётся список (list) ее элементов;
поскольку она не меняет исходную коллекцию, ее можно применять к неизменяемым коллекциям;
Поскольку при сортировке возвращаемых элементов нам не важно, был ли у элемента некий индекс в исходной коллекции, можно применять к неиндексированным коллекциям;
Имеет дополнительные не обязательные аргументы:
reverse=True — сортировка в обратном порядке
key=funcname (начиная с Python 2.4) — сортировка с помощью специальной функции funcname, она может быть как стандартной функцией Python, так и специально написанной вами для данной задачи функцией и лямбдой.

/&py
my_list = [2, 5, 1, 7, 3]
my_list_sorted = sorted(my_list)
print(my_list_sorted)       # [1, 2, 3, 5, 7]

my_set = {2, 5, 1, 7, 3}
my_set_sorted = sorted(my_set, reverse=True)
print(my_set_sorted)        # [7, 5, 3, 2, 1]
&py/

Пример сортировки списка строк по длине len() каждого элемента:

/&py
my_files = ['somecat.jpg', 'pc.png', 'apple.bmp', 'mydog.gif']
my_files_sorted = sorted(my_files, key=len)
print(my_files_sorted)      # ['pc.png', 'apple.bmp', 'mydog.gif', 'somecat.jpg']
&py/

2 Функция reversed()

Функция reversed() применяется для последовательностей и работает по другому:

возвращает генератор списка, а не сам список;
если нужно получить не генератор, а готовый список, результат можно обернуть в list() или же вместо reversed() воспользоваться срезом [: :-1];
она не сортирует элементы, а возвращает их в обратном порядке, то есть читает с конца списка;
из предыдущего пункта понятно, что если у нас коллекция неиндексированная — мы не можем вывести её элементы в обратном порядке и эта функция к таким коллекциям не применима — получим «TypeError: argument to reversed() must be a sequence»;
не позволяет использовать дополнительные аргументы — будет ошибка «TypeError: reversed() does not take keyword arguments».

/&py
my_list = [2, 5, 1, 7, 3]
my_list_sorted = reversed(my_list)
print(my_list_sorted)           # <listreverseiterator object at 0x7f8982121450>
print(list(my_list_sorted))     # [3, 7, 1, 5, 2]
print(my_list[::-1])            # [3, 7, 1, 5, 2] - тот же результат с помощью среза
&py/

3 Методы списка .sort() и .reverse()

У списка (и только у него) есть особые методы .sort() и .reverse() которые делают тоже самое, что соответствующие функции sorted() и reversed(), но при этом:

Меняют сам исходный список, а не генерируют новый;
Возвращают None, а не новый список;
поддерживают те же дополнительные аргументы;
в них не надо передавать сам список первым параметром, более того, если это сделать — будет ошибка — не верное количество аргументов.

/&py
my_list = [2, 5, 1, 7, 3]
my_list.sort()
print(my_list)          # [1, 2, 3, 5, 7]
&py/

Обратите внимание: Частая ошибка начинающих, которая не является ошибкой для интерпретатора, но приводит не к тому результату, который хотят получить.

/&py
my_list = [2, 5, 1, 7, 3]
my_list = my_list.sort()
print(my_list)          # None
&py/

4 Особенности сортировки словаря

В сортировке словаря есть свои особенности, вызванные тем, что элемент словаря — это пара ключ: значение.

Так же, не забываем, что говоря о сортировке словаря, мы имеем ввиду сортировку полученных из словаря данных для вывода или сохранения в индексированную коллекцию. Сохранить данные сортированными в самом стандартном словаре не получится, они в нем, как и других неиндексированных коллекциях находятся в произвольном порядке.

sorted(my_dict) — когда мы передаем в функцию сортировки словарь без вызова его дополнительных методов — идёт перебор только ключей, сортированный список ключей нам и возвращается;
sorted(my_dict.keys()) — тот же результат, что в предыдущем примере, но прописанный более явно;
sorted(my_dict.items()) — возвращается сортированный список кортежей (ключ, значение), сортированных по ключу;
sorted(my_dict.values()) — возвращается сортированный список значений

/&py
my_dict = {'a': 1, 'c': 3, 'e': 5, 'f': 6, 'b': 2, 'd': 4}
mysorted = sorted(my_dict)
print(mysorted)           # ['a', 'b', 'c', 'd', 'e', 'f']
mysorted = sorted(my_dict.items())
print(mysorted)           # [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5), ('f', 6)]
mysorted = sorted(my_dict.values())
print(mysorted)           # [1, 2, 3, 4, 5, 6]
&py/

Отдельные сложности может вызвать сортировка словаря не по ключам, а по значениям, если нам не просто нужен список значений, и именно выводить пары в порядке сортировки по значению.

Для решения этой задачи можно в качестве специальной функции сортировки передавать lambda-функцию lambda x: x[1] которая из получаемых на каждом этапе кортежей (ключ, значение) будет брать для сортировки второй элемент кортежа.

/&py
population = {"Shanghai": 24256800, "Karachi": 23500000, "Beijing": 21516000, "Delhi": 16787941}
# отсортируем по возрастанию населения:
population_sorted = sorted(population.items(), key=lambda x: x[1])
print(population_sorted)
# [('Delhi', 16787941), ('Beijing', 21516000), ('Karachi', 23500000), ('Shanghai', 24256800)]
&py/


5 Дополнительная информация по использованию параметра key при сортировке

Допустим, у нас есть список кортежей названий деталей и их стоимостей.
Нам нужно отсортировать его сначала по названию деталей, а одинаковые детали по убыванию цены.

/&py
shop = [('каретка', 1200), ('шатун', 1000), ('седло', 300),
        ('педаль', 100), ('седло', 1500), ('рама', 12000),
        ('обод', 2000), ('шатун', 200), ('седло', 2700)]

def prepare_item(item):
    return (item[0], -item[1])

shop.sort(key=prepare_item)
&py/

Результат сортировки

/&py
for det, price in shop:
    print('{:<10} цена: {:>5}р.'.format(det, price))

# каретка    цена:  1200р.
# обод       цена:  2000р.
# педаль     цена:   100р.
# рама       цена: 12000р.
# седло      цена:  2700р.
# седло      цена:  1500р.
# седло      цена:   300р.
# шатун      цена:  1000р.
# шатун      цена:   200р.
&py/

Перед тем, как сравнивать два элемента списка к ним применялась функция prepare_item, которая меняла знак у стоимости (функция применяется ровно по одному разу к каждому элементу. В результате при одинаковом первом значении сортировка по второму происходила в обратном порядке.

Чтобы не плодить утилитарные функции, вместо использования сторонней функции, того же эффекта можно добиться с использованием лямбда-функции.

/&py
# Данные скопировать из примера выше
shop.sort(key=lambda x: (x[0], -x[1]))
&py/

6 Устойчивость сортировки

Допустим данные нужно отсортировать сначала по столбцу А по возрастанию, затем по столбцу B по убыванию, и наконец по столбцу C снова по возрастанию.

Если данные в столбце B числовые, то при помощи подходящей функции в key можно поменять знак у элементов B, что приведёт к необходимому результату.
А если все данные текстовые? Тут есть такая возможность.
Дело в том, что сортировка sort в Python устойчивая (начиная с Python 2.2), то есть она не меняет порядок «одинаковых» элементов.

Поэтому можно просто отсортировать три раза по разным ключам:
/&py
data.sort(key=lambda x: x['C'])
data.sort(key=lambda x: x['B'], reverse=True)
data.sort(key=lambda x: x['А'])
&py/


Более конкретно про каждый тип

	Кортеж
Кортеж  --  это неизменяемый последовательный набор элементов. Он является неизменяемым, итерируемым объектом

Элементы кортежа могут быть представлены РАЗНЫМИ ТИПАМИ

Кортежи в python представляются классом tuple

Литерал кортежа:
Значения в круглых скобках, разделённые запятыми

Создать кортеж можно следующим образом:
1. Просто подсунув набор элементов
a = 1, 2, 3

2. Прописав кортеж литералом:
a = (1, 2, 3)

3. Сделать на основании другого объекта:
a = tuple(obj=())  --  obj iterable объект

Примечание:
Другим объектом может выступать и сам кортеж. То есть можно сделать кортеж из кортежа

Кортеж можно распаковать

Особенности кортежа:
1. Меньший размер по сравнению со списками
2. Неизменяемость
3. built-in тип
4. Коллекция


Операции над кортежами:
1. Сложение
Сложение двух кортежей возвращает кортеж состоящий из элементов обоих кортежей. При этом сохраняется порядок элементов. Сначала идут те, что были в правом кортеже, затем те, что были в левом
(1, 2) + (2, 3) вернёт нам (1, 2, 2, 3)

2. Оператор членства
7 in (1, 5, 8, 7, 7) вернёт True

3. Операторы сравнения
(1, 2, 3)  ==  (3, 2, 1) вернёт False
(1, 2, 7) > (1, 2, 6) вернёт True
(1, 2) < (1, 2, 3) вернёт True

4. Доступ по индексу
a = (1, 2, 3)
a[1] вернёт 2
(1, 2, 3, 4, 5, 6, 9)[4] вернёт 5

5. Срез
(1, 5, 3, 2, 7)[1:3] вернёт(5, 3) 

5. len
len((1, 3, 5)) вернёт 3

6. Умножение
(1, 2) * 7 вернёт (1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2)


Классовые методы:
1. count(self, value, /)  --  считает сколько value в кортеже
t = (7, 7, 7, 9, 6)
t.count(10) вернёт 0
t.count(7) вернёт 3
(7, 6, 6).count(6) вернёт 6

2. index(self, value, start=0, stop=9223372036854775807, /)  --  возвращает индекс первого встретившегося value начиная со start и заканчивая stop. Если не находит value, вызывает ошибку ValueError
(12, 4, 2, 7, 4, 53).index(7) вернёт 3
a = (5, 7, 3, 1, 7, 88)
a.index(7) вернёт 1
a.index(7, 2) вернёт 5
a.index(900) вызовет ошибку ValueError
a.index(7, 2, 4) вызовет ошибку ValueError
a.index(7, 2, 5) вернёт 4


Можно превести к строке


Как создать кортеж из 1 элемента:
(elem,)

Без запятой python воспринимает это, как выражение, которое нужно вычислить. И соответсвенно вычисляет, раскрывая скобки

	Списки
Список  --  это изменяемый последовательный набор элементов. Он является изменяемым итерируемым объектом

Элементы списка могут быть представлены РАЗНЫМИ ТИПАМИ

Списки в python представляются классом list

Литерал списка:
Значения в квадратных скобках, разделённые запятыми

Создать список можно следующим образом:
1. Прописав список литералом:
a = [1, 2, 3]

2. Сделать на основании другого объекта:
a = list(obj=[])  --  obj iterable объект

Примечание:
Другим объектом может выступать и сам список. То есть можно сделать список из другого списка

Список можно распаковать

Особенности списка:
1. Изменяемость
2. Последовательное хранение элементов
3. Распаковка неопределённого числа элементов делается в список
4. built-in тип
5. Коллекция

Распаковка:
Списки можно распаковать, как и кортежи

Распаковка в список:
*название_переменной = элемент1, элемент2, ..., элементN

Можно распаковать например только первые 3 элемента, а остальные запихнуть в список:
/&py
a, b, c, *args = 1, 2, 4, 5, 'sdg', 23
&py/

Это аналогично
/&py
a = 1
b = 2
c = 4
args = [5, 'sdg', 23]
&py/


Классовые методы:
1. append(el)  --  добавляет el в конец списка
/&py
a = ['l', 'o']
a.append('l')  # ['l', 'o', 'l']
&py/

2. insert(index, el)  --  добавляет el на место index. При этом все остальные элементы сдвигаются вправо
/&py
a = [1, 3, 3, 7]
a.insert(2, 74)  # [1, 3, 74, 3, 7]

a = [1, 3, 3, 7]
a.insert(9999999999999, 1)  # [1, 3, 3, 7, 1]
&py/


3. index(el)  --  возвращает индекс el. Если не находит, вызывает ошибку ValueError
/&py
a = ['a', 'b', 'c']
a.index('b')  # 1
a.index(4)  # ValueError: 4 not in list
&py/


4. pop([index])  --  возвращает элемент по индексу, удаляя его из списка. Если индекса не существует, InexError
/&py
a = [1, 2, 3, 4, 5]
b = a.pop(3)  # b - 4  a - [1, 2, 3, 5]
c = a.pop()  # c - 5  a - [1, 2, 3]
q = a.pop(-2)  # q - 2  a - [1, 3]
a.pop(999)  # IndexError: pop index out of range
[].pop()  # IndexError: pop from empty list
&py/


5. extend(collection)  --  добавляет в конец списка все элементы из collection, где collection - коллекция
/&py
a = []
a.extend((1, 2))  # [1, 2]
a.extend([3, 4])  # [1, 2, 3, 4]
a.extend({5, 6, 7})  # [1, 2, 3, 4, 5, 6, 7]

a = []
b = {'a': 10, 'b': 20}
a.extend(b)  # ['a', 'b']
a.extend(b.values())  # ['a', 'b', 10, 20]
a.extend(b.items())  # ['a', 'b', 10, 20, ('a', 10), ('b', 20)]

a = []
a.extend(b.keys())  # ['a', 'b']
&py/


6. remove(el)  --  удаляет первый попавшийся элемент из списка. Если нету такого элемента, ValueError
/&py
a = [1, 2, 3, 1]
a.remove(1)  # [2, 3, 1]
a.remove(1)  # [2, 3]
a.remove(5)  # ValueError: list.remove(x): x not in list
&py/


7. clear()  --  очищает список от всех элементов
/&py
a = ['Oh', 'my', 'god', '!!!', 1, 2, 3]
a.clear()  # []
&py/


8. copy()  --  возвращает копию списка
/&py
a = [1, 2, 3]
b = a
c = a.copy()
a == b  # True
a == c  # True
a is b  # True
a is c  # False
&py/


9. count(el)  --  возвращает количество el в списке
/&py
a = [1, 2, 2, 3, 3, 3, 4]
a.count(0)  # 0
a.count(1)  # 1
a.count(2)  # 2
a.count(3)  # 3
a.count(4)  # 1
a.count(5)  # 0
&py/


10. reverse()  --  элемент в списке задом наперёд
/&py
a = [1, 'l', (9,), 144, 'abc']
a.reverse()  # ['abc', 144, (9,), 'l', 1]
[1, 3, 2]  # [2, 3, 1]
a.reverse()  # [1, 'l', (9,), 144, 'abc']
&py/


11. sort(*, key=None, reverse=False)  --  сортирует список по возрастанию. key, reverse - ключевые аргументы. reverse - сортировать по убыванию. key - функция, применяемая к каждому элементу списка перед сортировкой, но сортирующая первоначальные элементы
Перечитай про key, пока не поймёшь
/&py
a = [3, 2, 5, 1, 2]
a.sort()  # [1, 2, 2, 3, 5]

a = ['b', 'z', 'q', 'f']
a.sort(reverse=True)  # ['z', 'q', 'f', 'b']

a = [1, '2', 6, 9, '5', 2]
a.sort(key=int)  # [1, '2', 2, '5', 6, 9]
&py/


	Словарь
Словарь почти= хэш-таблица

Словарь  --  это изменяемый неупорядоченный набор элементов "ключ:значение"
Ключ  --  уникальный, хэшируемый

Словари в python представляются классом dict

Литерал словаря:
{}

Примечание: внутри обязаны быть пары "ключ: значение". Пустые {} обозначают пустой словарь

Как создать словарь:
1. Литералом
/&py
a = {2: 3, 5: 6}
b = {}
&py/

2. Из другой коллекции, которая состоит из пар элементов: 1 - ключ, 2 - значение
/&py
a = dict([(1, 'a'), (2, 'b'), (3, 'c')])  # a = {1: 'a', 2: 'b', 3: 'c'}
&py/

Для этого может быть использована функция zip:
/&py
b = dict(zip((1, 2, 3, 4, 5), ('a', 'ab', 'b', 'bc', 'c')))  # b = {1: 'a', 2: 'ab',
                                                             #      3: 'b', 4: 'bc', 5: 'c'}
&py/

Особенности словаря:
1. Доступ к элементам можно рассматривать, как мгновенный (чуть-чуть наврал)
2. Ключи - уникальны, обязаны быть хэшируемыми, неизменяемыми
3. Элементы неупорядочены
4. **название обозначает, что название - словарь

Классовые методы:
1. setdefault(self, key, default=None, /)  --  задаёт значение default по ключу key. Если по этому улючу уже было значение, то также возвращает предыдущее значение

/&py
D = {1: 'abc', 2: ('vasya', 'petya')}
D.setdefault(3, 'ammonium')  # {1: 'abc', 2: ('vasya', 'petya'), 3: 'ammonium'}
b = D.setdefault(2, ['alex'])  # b = ('vasya', 'petya')  
                               # {1: 'abc', 2: ['alex'], 3: 'ammonium'}
D.setdefault(1)  # {1: None, 2: ['alex'], 3: 'ammonium'}
&py/


2. get(self, key, default=None, /)  --  возвращает значение по ключу key. Если не находит, возвращает default

/&py
D = {1: 'abc', 2: ('vasya', 'petya'), 3: 'ammonium'}
a = D.get(1)  # 'abc'
b = D.get(444)  # None
c = D.get(8, 'nothing')  # 'nothing'
&py/


3. items()  --  возвращает множество-подобный объект, предоставляющий отображение пар словаря

/&py
D = {1: 'lol', 'a': (1, 2), (95, 0): ['a', 'm', 'q']}
a = D.items()  # dict_items([(1, 'lol'), ('a', (1, 2)), ((95, 0), ['a', 'm', 'q'])])
&py/

dict_items можно кидать в цикл for, распаковывать, преобразовывать к другим коллекциям


4. keys()  --  возвращает множество-подобный объект, предоставляющий отображение ключей словаря

/&py
D = {1: 'lol', 'a': (1, 2), (95, 0): ['a', 'm', 'q']}
a = D.items()  # dict_keys([1, 'a', (95, 0)])
&py/

С dict_keys можно делать тоже, что и с dict_items


5. values()  --  возвращает множество-подобный объект, предоставляющий отображение значений словаря

/&py
D = {1: 'lol', 'a': (1, 2), (95, 0): ['a', 'm', 'q']}
a = D.values()  # dict_values(['lol', (1, 2), ['a', 'm', 'q']])
&py/

С dict_values можно делать тоже, что и с dict_items


6. pop(k[,d])  --  удаляет соответствующий ключ k и возвращает значение по этому ключу. Если ключа не находит возвращает d. Если не дано d вызывает ошибку KeyError

/&py
D = {'a': (1, 2), (95, 0): ['a', 'm', 'q']}
a = D.pop((95, 0))  # a = ['a', 'm', 'q']  D = {'a': (1, 2)}
b = D.pop(9, 'err')  # b = 'err'  D = {'a': (1, 2)}
D.pop(3, 'q')  # D = {'a': (1, 2)}
c = D.pop(10)  # KeyError: 10
&py/


7.  popitem()  --  удаляет пару из словаря и возвращает кортеж (ключ, значение). Ключи возвращаются в порядке LIFO (объясню это позже). Кидает ошибку KeyError, если словарь пустой

/&py
D = {1: 2,
     2: 3,
     3: 4}
a = D.popitem()  # (3, 4)  {1: 2, 2: 3}
D.popitem()  # (2, 3)  {1: 2}
D.popitem()  # (1, 2)  {}
D.popitem()  # KeyError: 'popitem(): dictionary is empty'
&py/


8. update([E, ]**F)  --  обновляет словарь значениями из E и F по следующим правилам:
E  --  iterable
Если передан аргумент E и имеет метод .keys(), тогда происходит: for k in E: D[k] = E[k]
Если передан аргумент E и не имеет метод .keys(), тогда происходит: for k, v in E: D[k] = v
Верхняя часть также может дополнятся: for k in F:  D[k] = F[k]

/&py
D = {}
D1 = {1: '2', 'a': 'b'}
D2 = ((5, 'c'), (6, 'm'))
D3 = {1: 2, 'a': 'q'}
D4 = [(3, 9), (4, 8)]
D.update(D1)  # {1: '2', 'a': 'b'}
D.update(D2)  # {1: '2', 'a': 'b', 5: 'c', 6: 'm'}
D.update(D3)  # {1: 2, 'a': 'q', 5: 'c', 6: 'm'}
D.update(D4, key1=4, another_key=9)  # {1: 2, 'a': 'q', 5: 'c', 6: 'm', 3: 9, 4: 8, 'key1': 4, 'another_key': 9}
&py/

9. Также возможен доступ по индексу(условно, реализация другая) D[b]. Это равносильно D.get(b)
/&py
D = {1: 2, 'a': 'b'}
D[1]  # 2
&py/


10. copy()  --  возвращает копию словаря с новым id


11. clear()  --  очищает словарь


	Множество
Множество  --  изменяемая коллекция, представляющая неупорядоченный набор уникальных элементов

В python множество представляется классами set и frozenset. set - изменяемое, frozenset - неизменяемое

Литерал множества(set):
{} где значения разделяются запятыми. Пустое множество: set()

Как создать множество
1. Литералом с 1 и больше элементов
/&py
a = {1, 2, '4'}
&py/

2. На основании другой коллекции set(col)
/&py
a = set((1, 2, 4, 5, 3, 2))
&py/

3. Пустое множество
/&py
a = set()
&py/


Особенности множества:
1. Элементы уникальны
2. Элементы обязан быть хэшируемыми
3. Множество неупорядоченно
4. Множество неиндексированно


Классовые функции множества:
1. add(el)  --  добавляет el в множество. Если такой элемент уже присутствует, то ничего не происходит
/&py
a = set()
a.add(9)  # {9}
a.add('abc')  # {9, 'abc'}
a.add(9)  # {9, 'abc'}
&py/


2. discard(el)  --  удаляет el из множества. Если такого не существует, то ничего не происходит
/&py
a = {1, 2, 3}
a.discard(1)  # {2, 3}
a.discard('this is not an error, ha!')  # {2, 3}
&py/


3. pop()  --  удаляет произвольный элемент из множества и возвращает его. Если множество пустое - KeyError
/&py
a = {1, 2, 3}
a.pop()  # 1
a.pop()  # 2
a.pop()  # 3
a.pop()  # KeyError: 'pop from an empty set'
&py/


4. remove(el)  --  удаляет el из множества. Если такого не существует - KeyError
/&py
a = {1, 2, 3}
a.remove(2)  # {1, 2}
a.remove(5)  # KeyError: 5
&py/


5. union(set1, ...)  --  возвращает объединение данного множества и остальных. НЕ меняет исходные множеста
/&py
a = {1, 2, 3}
b = {1, 4, 5}
c = {2, 1, 9}

a.union(b)  # {1, 2, 3, 4, 5}
set.union(a, b)  # {1, 2, 3, 4, 5}
set.union(c, a)  # {1, 2, 3, 9}
c.union(b)  # {1, 2, 4, 5, 9}
set.union(a, b, c)  # {1, 2, 3, 4, 5, 9}
a.union()  # {1, 2, 3}
set.union()  # TypeError: unbound method set.intersection() needs an argument
&py/

Примечание:
Предпочтительней set.union(...), так проще понимать, что мы объединяем
Также можно использовать |:  a | b


6. intersection(set1, ...)  --  возвращает пересечение данного множества и остальных. НЕ меняет исходные множества
/&py
a = {1, 2, 3}
b = {1, 4, 5}
c = {2, 1, 9}
d = {}

a.intersection(b)  # {1}
set.intersection(a, b, c)  # {1}
d.intersection(a, b, c)  # {}
set.intersection(b, c, d)  # {}
a.intersection()  # {1, 2, 3}
set.intersection()  # TypeError: unbound method set.intersection() needs an argument
&py/

Примечание:
Предпочтительней set.intersection(...), так проще понимать, что мы пересекаем
Также можно использовать &:  a & b


7. difference(set1, ...)  --  возвращает все элементы, которые есть в начальном множестве, но нет в других. НЕ меняет исходное множество
/&py
a = {1, 2, 3}
b = {2, 3, 4}
c = {3, 6, 9}

a.difference(b)  # {1}
b.difference(a)  # {4}
set.difference(b, c)  # {2, 4}
set.difference(a, b, c)  # {1}
set.difference(c, a, b)  # {9, 6}
a.difference()  # {1, 2, 3}
set.difference()  # TypeError: unbound method set.difference() needs an argument
&py/

Примечание:
Предпочтительней a.difference(...), так как разница именно из первого множества
set.difference(set1, set2, ...) равносильно set1 - set2 - ... равносильно set1.difference(set2, ...)


8. symmetric_difference(set1)  --  возвращает множество, состоящее из элементов которых нет в изначальном множестве, но есть в set1
/&py
a = {1, 2, 3}
b = {2, 3, 4}
c = {1, 3, 5}

a.symmetric_difference(b)  # {1, 4}
set.symmetric_difference(b, c)  # {1, 2, 4, 5}
{5, 6}.symmetric_difference(c)  # {1, 3}
&py/


9. update(set1, ...)  --  то же, что и union, но МЕНЯЕТ изначальное множество


10. difference_update(set1, ...)  --  то же, что и difference, но МЕНЯЕТ изначальное множество


11. intersection_update(set1, ...)  --  то же, что и intersection, но МЕНЯЕТ изначальное множество


12. symmetric_difference_update(set1)  --  то же, что и symmetric_difference, но МЕНЯЕТ изначальное множество


13. isdisjoint(set1)  --  True, если два множества не пересекаются. Иначе False
/&py
a = {1, 2, 3}
b = {4, 5, 6}

a.isdisjoint(b)  # True
set.isdisjoint(b, {4, 7, 8})  # False
{8, 9, 10}.isdisjoint({5, 6, 7})  # True
&py/


14. issubset(set1)  --  True, если начальное множество является подмножеством set1. Иначе False
/&py
a = {1, 2}
b = {1, 2, 3}

a.issubset(b)  # True
b.issubset(a)  # False
{1, 2}.issubset(a)  # True
&py/


15. issuperset(set1)  --  True, если начальное множество является надмножеством set1. Иначе False
/&py
a = {1, 2}
b = {1, 2, 3}

a.issuperset(b)  # False
b.issuperset(a)  # True
{1, 2}.issuperset(a)  # True
&py/


16. clear()  --  очищает множество


17. copy()  --  возвращает копию множества с новым идентификатором


	frozenset
Это тупо неизменяемое множество. С ним можно всё, что не меняет изначальное множество


	Строки
Строка  --  неизменяемая последовательность, представляющая текстовые данные

Строки в python представляются классом str

Литералы строк:
''
""

Можно использовать, как двойные, так и одинарные кавычки, разницы нет


Как можно создать строку:
1. Литералом
/&py
a = 'abc'
b = "I'm a person"
&py/

2. Из другого объекта
/&py
a = str(1)
b = str(True)
c = str((1, 2))
&py/


Классовые методы:
1. count(sub[, start[, end]])  --  считает, сколько непересекающихся строк sub в срезе [start:end]
/&py
a = 'abcabc111111'
a.count('1')  # 6
a.count('abc')  # 2
a.count('bc', 2)  # 1
a.count('11', 6, 11)  # 2
&py/


2. find(sub[, start[, end]])  --  возвращает индекс первой строки sub в срезе [start:end]. Если не находит, возвращает -1

/&py
sentence = 'Она продает ракушки на берегу моря. Товары, которые она продает, безусловно, ракушки.'
sentence.find('ракушки')  # 10
sentence.find('ракушки',0,9)  # -1
sentence.find('р',5,10)  # 8
&py/


3. index(sub[, start[, end]])  --  аналогично find, но если не находит ValueError
/&py
sentence = 'Она продает ракушки на берегу моря. Товары, которые она продает, безусловно, ракушки.'
sentence.index('ракушки')  # 10
sentence.index('ракушки',0,9)  # ValueError: substring not found
sentence.index('р',5,10)  # 8
&py/


4. isdigit(self, /)  --  возвращает правду, если строка является целым числом и содержит как минимум 1 символ
/&py
''.isdigit()  # False
'0'.isdigit()  # True
'1'.isdigit()  # True
'1000'.isdigit()  # True
'1.1'.isdigit()  # False
'1 000'.isdigit()  # False
'a'.isdigit()  # False
&py/


5. replace(self, old, new, count=-1, /)  --  возвращает новую строку, в которой все подстроки old заменены на новые подстроки new. Заменяет не больше, чем count подстрок. Если count = -1 заменяет все подстроки
/&py
my_str = 'barbarian'
my_str = my_str.replace('bar', 'mur')  # 'murmurian'
my_str = my_str.replace('mur', 'bur', 1)  # 'burmurian'
'1111111'.replace('1', '22')  # '22222222222222'
'1111111'.replace('111', '3')  # '331'
&py/


Остальное мы рассмотрим в отдельной теме

	git
Git  --  это распределённая система управления версиями

Нам она понадобится для коллаборация кода и текста. То есть чтобы мы могли передавать информацию в общее хранилище и это всё без флешек

Как установить git: скачать установщик и установить

Как работать с git:
1. Через консоль git
2. Через sublime text 3
3. Через PyCharm
4. Через консоль windows - cmd

Мы будем использовать 4 вариант. Ну по-крайней мере я буду учить тебя именно ему

Для начала нам понадобиться сам проект. Его можно получить двумя способами:
1. Создать новый и настроить всё от руки
2. Клонировать его с общего репозитория

Мы рассмотрим 2 варианта

В обоих случаях нам понадобится папка с проектом поэтому я тебе советую создать в документах папку GitHub и там создать папку Programming - сам проект

Затем необходимо перейти в неё в консоли

[]  --  значит аргумент необязательный

Рассмотрим команды git:
1. clone

Скачивает репозиторий с инета или ещё откуда

Использование:
git clone [<options>] [--] <repo> [<dir>]

<options>  --  доп настройки, которых мы не коснёмся
<repo>  --  ссылка на репозиторий
<dir>  --  куда его скачать. Если не указано в текущую папку

2. status

Выводит текущий статус данного проекта. То есть какие изменения ты внесла, что добавила к commit-у и т.д.

Использование:
git status [<options>…​] [--] [<pathspec>…​]

<options>  --  доп. настройки
<pathspec>  --  спецификации пути, в которых я не шарю


options:
-s
--short
Выводят информацию о проекте кратко

-b
--branch
Показывают информации о конкретной ветке инфу об отслеживании даже в кратком формате

--long
Показывает информацию в длинном формате. Используется по дефолту

-u[<mode>]
--untracked-files[=<mode>]
Показывать или нет файлы, которые не были добавлены в commit
<mode>  --  доп. настройки
no - не показывать
normal - показывать файлы и директории не добавленные в commit
all - также показывать каждый файл отдельно в неотслеженных директориях

--column[=<options>]
--no-column
Показывать неотслеженные файлы и директории в колоннах

Как выводиться если ты используешь -s:
Выводиться список изменённых файлов и слева две колонки из символов ниже. Левая колонка отвечает за ветку при слиянии, правая за локальную версию


Чё выводится:
' ' = unmodified
M = modified
A = added
D = deleted
R = renamed
C = copied
U = updated but unmerged
? - untracked
! - ignored

3. log
Показывает лог коммитов

Использование
git log [<options>] [<revision range>] [[--] <path>…​]

<options>  --  настройки
<revision range>  --  показывает коммиты в этой области
<path>  --  путь к репозиторию

Чтобы выйти из режима log нужно нажать q
Чтобы листать можно использовать стрелочки вверх вниз и enter только вниз

options:
--full-diff
Показывает полную разницу, а не только изменения

--log-size
Включает в каждый коммит строку с размером коммита


4. add
Добавляет файлы в коммит

Использование:
git add [--verbose | -v] [--dry-run | -n] [--force | -f] [--interactive | -i] [--patch | -p]
          [--edit | -e] [--[no-]all | --[no-]ignore-removal | [--update | -u]]
          [--intent-to-add | -N] [--refresh] [--ignore-errors] [--ignore-missing] [--renormalize]
          [--chmod=(+|-)x] [--pathspec-from-file=<file> [--pathspec-file-nul]]
          [--] [<pathspec>…​]

-n
--dry-run
По факту не добавляет файлы, а просто показывает существуют ли они и будут ли добавлены или проигнорированы

-f
--force
Позволяет добавлять даже проигнорированные файлы

-A
--all
Добавляет сразу все файлы в коммит

<pathpsec>  --  путь к файлам, которые будут добавлены. Это может быть как уникальный файл, так и папка

5. commit
Делает коммит всех добавленных файлов. То есть собирает указанные тобой локальные изменения и сохраняет их в историю

Использование:
git commit [-a | --interactive | --patch] [-s] [-v] [-u<mode>] [--amend]
           [--dry-run] [(-c | -C | --fixup | --squash) <commit>]
           [-F <file> | -m <msg>] [--reset-author] [--allow-empty]
           [--allow-empty-message] [--no-verify] [-e] [--author=<author>]
           [--date=<date>] [--cleanup=<mode>] [--[no-]status]
           [-i | -o] [--pathspec-from-file=<file> [--pathspec-file-nul]]
           [-S[<keyid>]] [--] [<pathspec>…​]

-m <msg>
Позволяет дописать сообщение к коммиту. Может быть использовано несколько раз
<msg> - сообщение. Желательно в двойных кавычках

6. push
Кидает накопившиеся коммиты в общий репозиторий

Использование:
git push [--all | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack=<git-receive-pack>]
           [--repo=<repository>] [-f | --force] [-d | --delete] [--prune] [-v | --verbose]
           [-u | --set-upstream] [-o <string> | --push-option=<string>]
           [--[no-]signed|--signed=(true|false|if-asked)]
           [--force-with-lease[=<refname>[:<expect>]] [--force-if-includes]]
           [--no-verify] [<repository> [<refspec>…​]]
-u
--set-upstream
Задаёт поток. Вспоминай лекцию

<repository>  --  конкретный репозиторий

7. pull
Перетягивает коммиты, которые лежат в общем репозитории в локальный

Использование:
git pull [<options>] [<repository> [<refspec>…​]]

<options>  --  настройки
<repository>  --  репозиторий

8. init
Создаёт пустой git репозиторий или перезапускает имеющийся

git init [-q | --quiet] [--bare] [--template=<template_directory>]
          [--separate-git-dir <git dir>] [--object-format=<format>]
          [-b <branch-name> | --initial-branch=<branch-name>]
          [--shared[=<permissions>]] [directory]

9. remote
Менеджит набор репозиториев

Использование:
Вариаций куча, но мы рассмотрим единственную
git remote add [-t <branch>] [-m <master>] [-f] [--[no-]tags] [--mirror=(fetch|push)] <name> <url>

<name>  --  название репозитория
<url>  --  ссылка на общий репозиторий

Далее [] обозначают просто аргументы

Работа с ветками
	1. Как создать ветку:
	    git checkout -b [новая_ветка]

	2. Как сменить ветку:
	    git switch [ветка]
	    Если работаешь с локальным репозиторием, его имя указывать не обязательно

	3. Как удалить ветку:
	    git branch -d [ветка]

	4. Как залить ветку в репозиторий:
	    git push origin [ветка]

	5. Чтобы слить ветку с данной, в которой ты работаешь:
	    git merge [ветка]

	6. Ветки можно сравнить:
	    git diff [одна_ветка] [другая_ветка]

	7. Вот черт, я не то смержил!:
	    1. Ctrl+Z для HEAD:
	        git checkout -- [имя_файла]

	    2. Но если проблема находится аж в локальном репозитории, то зачисти там все и верни версию с сервера:
	        git fetch origin 
	        git reset --hard origin/master

Немножко чёрной магии для красивой жизни:
git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%C(bold blue)<%an>%Creset' --abbrev-commit"

После этой команды можно прописывать в репозитории git lg и будет информативный log. Информативнее и приятнее раз в 20


Чтобы тебе в консоль спокойно выводились русские буквы нужно прописать в config'е репозитория в область core'а следующую настройку:
quotepath = false



	Выражения генераторы(comprehension expression)
1.1. Что и зачем:
Генераторы выражений предназначены для компактного и удобного способа генерации коллекций элементов, а также преобразования одного типа коллекций в другой

В процессе генерации или преобразования возможно применение условий и модификация элементов

Генераторы выражений являются синтаксическим сахаром и не решают задач, которые нельзя было бы решить без их использования

1.2. Преимущества генераторов:
Более короткий и удобный синтаксис, чем генерация в обычном цикле

Более понятный и читаемый синтаксис чем функциональный аналог сочетающий одновременное применение функций map(), filter() и lambda

В целом: быстрее набирать, легче читать, особенно когда подобных операций много в коде

1.3. Классификация и особенности:
Выражение-генератор (generator expression) — выражение в круглых скобках которое выдает создает на каждой итерации новый элемент по правилам

Генератор коллекции — обобщенное название для генератора списка (list comprehension), генератора словаря (dictionary comprehension) и генератора множества (set comprehension)

Смотри рисунок 17


2. Синтаксис

Для начала взгляни на общий синтаксис

Смотри рисунок 18

Ввод — это итератор — это может быть функция-генератор, выражение-генератор, коллекция — любой объект поддерживающий итерацию по нему

Условие — это фильтр при выполнении которого элемент пойдет в финальное выражение, если элемент ему не удовлетворяет, он будет пропущен

Финальное выражение — преобразование каждого выбранного элемента перед его выводом или просто вывод без изменений

2.1. Базовый синтаксис

/&py
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]    # Пусть у нас есть исходный список
list_b = [x for x in list_a]           # Создадим новый список используя генератор списка
print(list_b)                          # [-2, -1, 0, 1, 2, 3, 4, 5]
print(list_a is list_b)                # False - это разные объекты!
&py/

2.2. Добавляем условие для фильтрации
Важно: Условие проверяется на каждой итерации, и только элементы ему удовлетворяющие идут в обработку в выражении

Теперь мы берём в список только чётные элементы

/&py
# if x % 2 == 0 - остаток от деления на 2 равен нулю - число четное
list_a = [-2, -1, 0, 1, 2, 3, 4, 5] 
list_b = [x for x in list_a if x % 2 == 0]
print(list_b)   # [-2, 0, 2, 4]
&py/

Можно использовать несколько условий:
/&py
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
list_b = [x for x in list_a if x % 2 == 0 and x > 0]
# берем те x, которые одновременно четные и больше нуля
print(list_b)   # [2, 4]
&py/

2.3. Добавляем обработку элемента в выражении
Важно: Выражение выполняется независимо на каждой итерации, обрабатывая каждый элемент индивидуально

Посчитаем только квадраты
/&py
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
list_b = [x**2 for x in list_a]
print(list_b)   # [4, 1, 0, 1, 4, 9, 16, 25]
&py/

Посчитаем длины строк
/&py
list_a = ['a', 'abc', 'abcde']
list_b = [len(x) for x in list_a]
print(list_b)   # [1, 3, 5]
&py/

2.4. Ветвление выражения
Обрати внимание: Мы можем использовать (начиная с Python 2.5) в выражении конструкцию if-else для ветвления финального выражения

В таком случае:

Условия ветвления пишутся не после, а перед итератором

В данном случае if-else это не фильтр перед выполнением выражения, а ветвление самого выражения, то есть переменная уже прошла фильтр, но в зависимости от условия может быть обработана по-разному!

/&py
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
list_b = [x if x < 0 else x**2 for x in list_a]
# Если x-отрицательное - берем x, в остальных случаях - берем квадрат x
print(list_b)   # [-2, -1, 0, 1, 4, 9, 16, 25]
&py/

Никто не запрещает комбинировать фильтрацию и ветвление:

/&py
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
list_b = [x**3 if x < 0 else x**2 for x in list_a if x % 2 == 0]
# вначале фильтр пропускает в выражение только четные значения
# после этого ветвление в выражении для отрицательных возводит в куб, а для остальных в квадрат
print(list_b)   # [-8, 0, 4, 16]
&py/

Можно было бы использовать цикл:
/&py
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
list_b = []
for x in list_a:
    if x % 2 == 0:
        if x < 0:
            list_b.append(x ** 3)
        else:
            list_b.append(x ** 2)
print(list_b)   # [-8, 0, 4, 16]
&py/

Улучшаем читаемость:
/&py
numbers = range(10)

# Before
squared_evens = [n ** 2 for n in numbers if n % 2 == 0]

# After
squared_evens = [
    n ** 2
    for n in numbers
    if n % 2 == 0
]
&py/


3. Аналоги в виде цикла for и в виде функций
Задача: сделаем из списка чисел список квадратов четных чисел

3.1. Решение с помощью генератора списка:
/&py
numbers = range(10)
squared_evens = [n ** 2 for n in numbers if n % 2 == 0]
print(squared_evens)   # [0, 4, 16, 36, 64]
&py/

3.2. Решение c помощью цикла for:
Важно: Каждый генератор выражений можно переписать в виде цикла for, но не каждый цикл for можно представить в виде такого выражения.

/&py
numbers = range(10)
squared_evens = []
for n in numbers:
    if n % 2 == 0:
        squared_evens.append(n ** 2)
print(squared_evens)   # [0, 4, 16, 36, 64]
&py/

3.3. Решение с помощью функций:
/&py
numbers = range(10)
squared_evens = map(lambda n: n ** 2, filter(lambda n: n % 2 == 0, numbers))
print(squared_evens)         # <map object at 0x7f661e5dba20>
print(list(squared_evens))   # [0, 4, 16, 36, 64]
# Примечание: в Python 2 в переменной squared_evens окажется сразу список, а в Python 3 «map object», который мы превращаем в список с помощью list()
&py/


4. Выражения-генераторы
Основное их отличие от генераторов коллекций в том, что они выдают элемент по-одному, не загружая в память сразу всю коллекцию

Особенности выражений-генераторов:

4.1. Генератор нельзя писать без скобок — это синтаксическая ошибка
/&py
# my_gen = i for i in list_a      # SyntaxError: invalid syntax
&py/

4.2. При передаче в функцию дополнительные скобки необязательны
/&py
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_sum = sum(i for i in list_a)
# my_sum = sum((i for i in list_a))  # так тоже можно
print(my_sum)   # 12
&py/

4.3. Нельзя получить длину функцией len()
/&py
# my_len = len(i for i in list_a)  # TypeError: object of type 'generator' has no len()
&py/

4.4. Нельзя распечатать элементы функцией print()
/&py
print(my_gen)   # <generator object <genexpr> at 0x7f162db32af0>
&py/

4.5. Обрати внимание, что после прохождения по выражению-генератору оно остается пустым!
/&py
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_gen = (i for i in list_a)
print(sum(my_gen))  # 12
print(sum(my_gen))  # 0
&py/

4.6. Выражение-генератор может быть бесконечным
/&py
import itertools
inf_gen = (x for x in itertools.count())  # бесконечный генератор от 0 to бесконечности!
&py/

4.7. К выражению-генератору не применимы срезы
/&py
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_gen = (i for i in list_a)
my_gen_sliced = my_gen[1:3]
# TypeError: 'generator' object is not subscriptable
&py/

4.8. Из генератора легко получать нужную коллекцию

5. Генерация стандартных коллекций

5.1. Создание коллекций из выражения-генератора

Передачей готового выражения-генератора присвоенного переменной в функцию создания коллекции.

/&py
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_gen = (i for i in list_a)   # выражение-генератор
my_list = list(my_gen) 
print(my_list)          # [-2, -1, 0, 1, 2, 3, 4, 5]
&py/

Написание выражения-генератора сразу внутри скобок вызываемой функции создания коллекции.

/&py
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_list = list(i for i in list_a)
print(my_list)          # [-2, -1, 0, 1, 2, 3, 4, 5]
&py/

Пример выше справедлив и для кортежей, множеств и frozenset

5.2. Специальный синтаксис генераторов коллекций
Обрати внимание, что для генерации множества и словаря используются одинаковые скобки, разница в том, что у словаря указывается двойной элемент ключ: значение

Генератор списка (list comprehension)

/&py
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_list = [i for i in list_a]
print(my_list)          # [-2, -1, 0, 1, 2, 3, 4, 5]
&py/

Не пиши круглые скобки в квадратных!

/&py
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_list = [(i for i in list_a)]
print(my_list)          # [<generator object <genexpr> at 0x7fb81103bf68>]
&py/

Генератор множества (set comprehension)

/&py
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_set= {i for i in list_a}
print(my_set)       # {0, 1, 2, 3, 4, 5, -1, -2} - порядок случаен
&py/

Генератор словаря (dictionary comprehension)
переворачивание словаря

/&py
dict_abc = {'a': 1, 'b': 2, 'c': 3, 'd': 3}
dict_123 = {v: k for k, v in dict_abc.items()}
print(dict_123)  # {1: 'a', 2: 'b', 3: 'd'}
                 # Обратите внимание, мы потеряли "с"! Так как значения были одинаковы, 
                 # то когда они стали ключами, только последнее значение сохранилось.
&py/

Словарь из списка:
/&py
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
dict_a = {x: x**2 for x in list_a}
print(dict_a)   # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, -2: 4, -1: 1, 5: 25}
&py/

Важно! Такой синтаксис создания словаря работает только в фигурных скобках, выражение-генератор так создать нельзя, для этого используется немного другой синтаксис:
/&py
# dict_gen = (x: x**2 for x in list_a)      # SyntaxError: invalid syntax
dict_gen = ((x, x ** 2) for x in list_a)    # Корректный вариант генератора-выражения для словаря
# dict_a = dict(x: x**2 for x in list_a)    # SyntaxError: invalid syntax
dict_a = dict((x, x ** 2) for x in list_a)  # Корректный вариант синтаксиса от @longclaps
&py/

5.3. Генерация строк

Для создания строки вместо синтаксиса выражений-генераторов используется метод строки .join(), которому в качестве аргументов можно передать выражение генератор.
Обрати внимание: элементы коллекции для объединения в строку должны быть строками!

/&py
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
# используем генератор прямо в .join() одновременно приводя элементы к строковому типу
my_str = ''.join(str(x) for x in list_a)
print(my_str)  # -2-1012345
&py/

6. Периодичность и частичный перебор

6.1. Работа с enumerate()
enumerate  --  итерируемый объект, который построен следующим образом: сначало идёт индекс, а затем сам элемент. Он бывает полезен

for i, x in enumerate(iterable)
i  --  индекс
x  --  элемент

/&py
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
list_d = [(i, x) for i, x in enumerate(list_a)]
print(list_d)   # [(0, -2), (1, -1), (2, 0), (3, 1), (4, 2), (5, 3), (6, 4), (7, 5)]
&py/

Выберем в генераторе списка каждый третий элемент из исходного списка:
/&py
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
list_e = [x for i, x in enumerate(list_a, 1) if i % 3 == 0]
print(list_e)   # [0, 3]
&py/


	Возможны два варианта вызова функции enumerate():
enumerate(iterator) без второго параметра считает с 0.
enumerate(iterator, start) — начинает считать с значения start. Удобно, например, если нам надо считать с 1, а не 0.

enumerate() возвращает кортеж из порядкового номера и значения текущего элемента итератора. Кортеж в выражении-генераторе результате можно получить двумя способами:
(i, j) for i, j in enumerate(iterator) — скобки в первой паре нужны!
pair for pair in enumerate(mylist) — мы работаем сразу с парой

Индексы считаются для всех обработанных элементов, без учета прошли они в дальнейшем условие или нет!

/&py
first_ten_even = [(i, x) for i, x in enumerate(range(10)) if x % 2 == 0]
print(first_ten_even)   # [(0, 0), (2, 2), (4, 4), (6, 6), (8, 8)]
&py/

Функция enumerate() не обращается к каким-то внутренним атрибутам коллекции, а просто реализует счетчик обработанных элементов, поэтому ничего не мешает ее использовать для неупорядоченных коллекций не имеющих индексации

Если мы ограничиваем количество элементов включенных в результат по enumerate() счетчику (например if i < 10), то итератор будет все равно обработан целиком, что в случае огромной коллекции будет очень ресурс-затратно

6.2. Перебор части итерируемого
/&py
islice() из itertools
import itertools
first_ten = (itertools.islice((x for x in range(1000000000) if x % 2 == 0), 10))
print(list(first_ten))  # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
&py/

7. Вложенные циклы и генераторы

7.1. Вложенные циклы
В результате генерации получаем одномерную структуру

Важно! При работае с вложенными циклами внутри генератора выражений порядок следования инструкций for in будет такой же (слева-направо), как и в аналогичном решении без генератора, только на циклах (сверху-вниз)! Тоже справедливо и при более глубоких уровнях вложенности

7.1.1. Вложенные циклы for где циклы идут по независимым итераторам
Общий синтаксис: [expression for x in iter1 for y in iter2]
Применение: генерируем одномерную структуру, используя данные из двух итераторов

Создадим словарь, используя кортежи координат как ключи, заполнив для начала его значения нулями:

/&py
rows = 1, 2, 3
cols = 'a', 'b'
my_dict = {(col, row): 0 for row in rows for col in cols}
print(my_dict)  # {('a', 1): 0, ('b', 2): 0, ('b', 3): 0, ('b', 1): 0, ('a', 3): 0, ('a', 2): 0}
&py/

Тоже можно сделать и с дополнительными условиями-фильтрами в каждом цикле:

/&py
rows = 1, 2, 3, -4, -5
cols = 'a', 'b', 'abc'
# Для наглядности разнесем на несколько строк
my_dict = {
    (col, row): 0  # каждый элемент состоит из ключа-кортежа и нулевого знаечния
    for row in rows if row > 0   # Только положительные значения
    for col in cols if len(col) == 1  # Только односимвольные
    }
print(my_dict)  # {('a', 1): 0, ('b', 2): 0, ('b', 3): 0, ('b', 1): 0, ('a', 3): 0, ('a', 2): 0}
&py/


7.1.2. Вложенные циклы for где внутренний цикл идет по результату внешнего цикла
Общий синтаксис: [expression for x in iterator for y in x]
Применение: Стандартный подход, когда нам надо обходить двумерную структуру данных, превращая ее в «плоскую» одномерную. В данном случае, мы во внешнем цикле проходим по строкам, а во внутреннем по элементам каждой строки нашей двумерной структуры

Допустим у нас есть двумерная матрица  --  список списков. И мы желаем преобразовать ее в плоский одномерный список

/&py
matrix = [[0, 1, 2, 3],
          [10, 11, 12, 13],
          [20, 21, 22, 23]]

# Решение с помощью генератора списка:
flattened = [n for row in matrix for n in row]
print(flattened)    # [0, 1, 2, 3, 10, 11, 12, 13, 20, 21, 22, 23]
&py/

То же с циклами:
/&py
flattened = []
for row in matrix:
    for n in row:
        flattened.append(n)
print(flattened)
&py/

Изящные решения:
/&py
import itertools
flattened = list(itertools.chain.from_iterable(matrix))
# Данный подход намного быстрее генератора списков 
# и рекомендован к использованию для подобных задач

flattened = sum(a, [])
# sum(a, []) имеет квадратическую сложность(O(n^2)) 
# и потому совсем не рекомендуется к использованию для таких целей
&py/

7.2. Вложенные генераторы
Вложенными могут быть не только циклы for внутри выражения-генератора, но и сами генераторы.
Такой подход применяется когда нам надо строить двумерную структуру

Важно!: В отличии от примеров выше с вложенными циклами, для вложенных генераторов, вначале обрабатывается внешний генератор, потом внутренний, то есть порядок идет справа-налево

7.2.1. — Вложенный генератор внутри генератора — двумерная из двух одномерных
Общий синтаксис: [[expression for y in iter2] for x in iter1]
Применение: генерируем двумерную структуру, используя данные из двух одномерных итераторов

Для примера создадим матрицу из 5 столбцов и 3 строк и заполним ее нулями:

/&py
w, h = 5, 3  # зададим ширину и высотку матрицы
matrix = [[0 for x in range(w)] for y in range(h)]
print(matrix)   # [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]
&py/

С помощью циклов(обрати внимание на порядок циклов):
/&py
matrix = []
for y in range(h):
    new_row = []
    for x in range(w):
        new_row.append(0)
    matrix.append(new_row)
print(matrix)   # [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]
&py/

После создания можно работать с матрицей, как с двумерным объектом:
/&py
# теперь можно добавлять значения по координатам (координаты - индексы в списке списков)
matrix[0][0] = 1
matrix[1][3] = 3
print(matrix)   # [[1, 0, 0, 0, 0], [0, 0, 0, 3, 0], [0, 0, 0, 0, 0]]

# Получаем значение по произвольным координатам
x, y = 1, 3
print(matrix[x][y])  # 3
&py/

7.2.2. — Вложенный генератор внутри генератора — двумерная из двумерной
Общий синтаксис: [[expression for y in x] for x in iterator]
Применение: Обходим двумерную структуру данных, сохраняя результат в другую двумерную структуру

Возьмем матрицу:

/&py
matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
&py/

Возведем каждый элемент матрицы в квадрат:

/&py
squared = [[cell**2 for cell in row] for row in matrix]
print(squared)    # [[1, 4, 9, 16], [25, 36, 49, 64], [81, 100, 121, 144]]
&py/

Вложенные циклы:
/&py
squared = []
for row in matrix:
    new_row = []
    for cell in row:
        new_row.append(cell**2)
    squared.append(new_row)
print(squared)    # [[1, 4, 9, 16], [25, 36, 49, 64], [81, 100, 121, 144]]
&py/

Обобщим вышеперечисленные варианты:
Смотри рисунок 19

7.3. — Генератор итерирующийся по генератору
Допустим у нас есть два таких генератора списков:
/&py
list_a = [x for x in range(-2, 4)]    # Так сделано для дальнейшего примера синтаксиса, 
                                      # конечно в подобной задаче досточно только range(-2, 4)
list_b = [x**2 for x in list_a]
&py/

Тоже самое можно записать и в одно выражение, подставив вместо list_a его генератор списка:
/&py
list_c = [x**2 for x in [x for x in range(-2, 4)]]
print(list_c)  # [4, 1, 0, 1, 4, 9]
&py/

Преимущество от комбинирования генераторов на примере сложной функции f(x) = u(v(x)):
/&py
list_c = [t + t ** 2  for t in (x ** 3 + x ** 4 for x in range(-2, 4))]
&py/

8. Использование range()

Особенности функции range():

Наиболее часто функция range() применяется для запуска цикла for нужное количество раз. Например, смотри генерацию матрицы в примерах выше

В Python 3 range() возвращает генератор, который при каждом к нему обращении выдает очередной элемент

Используемые параметры аналогичны таковым в срезах (кроме первого примера с одним параметром):

range(stop) — в данном случае с 0 до stop-1;
range(start, stop) — Аналогично примеру выше, но можно задать начало отличное от нуля, можно и отрицательное;
range(start, stop, step) — Добавляем параметр шага, который может быть отрицательным, тогда перебор в обратном порядке

В Python 2 были 2 функции:

range(...) которая аналогична выражению list(range(...)) в Python 3 — то есть она выдавала не итератор, а сразу готовый список. То есть все проблемы возможной нехватки памяти, описанные в разделе 4 актуальны, и использовать ее в Python 2 надо очень аккуратно!
xrange(...) — которая работала аналогично range(...) в Python 3 и из 3 версии была исключена.

Примеры использования:

/&py
print(list(range(5)))           # [0, 1, 2, 3, 4]
print(list(range(-2, 5)))       # [-2, -1, 0, 1, 2, 3, 4]
print(list(range(5, -2, -2)))   # [5, 3, 1, -1]
&py/

9. Приложение 1. Дополнительные примеры

9.1. Последовательный проход по нескольким спискам

/&py
import itertools
l1 = [1,2,3]
l2 = [10,20,30]
result = [l*2 for l in itertools.chain(l1, l2)]
print(result)   # [2, 4, 6, 20, 40, 60]
&py/

9.2. Транспозиция матрицы
(Преобразование матрицы, когда строки меняются местами со столбцами)

Возьмем матрицу

/&py
matrix = [[1, 2, 3, 4],
          [5, 6, 7, 8],
          [9, 10, 11, 12]]
&py/

Сделаем ее транспозицию с помощью генератора выражений:

/&py
transposed = [[row[i] for row in matrix] for i in range(len(matrix[0]))]
print(transposed)  # [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
&py/

С помощью циклов:
/&py
transposed = []
for i in range(len(matrix[0])):
    new_row = []
    for row in matrix:
        new_row.append(row[i])
    transposed.append(new_row)
print(transposed)  # [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
&py/

И немного черной магии:
/&py
transposed = list(map(list, zip(*matrix)))
print(transposed)  # [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
&py/

9.3 Задача выбора только рабочих дней

/&py
# Формируем список дней от 1 до 31 с которым будем работать
days = [d for d in range(1, 32)]

# Делим список дней на недели
weeks = [days[i:i+7] for i in range(0, len(days), 7)]
print(weeks)   # [[1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12, 13, 14], [15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28], [29, 30, 31]]

# Выбираем в каждой неделе только первые 5 рабочих дней, отбрасывая остальные
work_weeks = [week[0:5] for week in weeks]
print(work_weeks)   # [[1, 2, 3, 4, 5], [8, 9, 10, 11, 12], [15, 16, 17, 18, 19], [22, 23, 24, 25, 26], [29, 30, 31]]

# Если нужно одним списком дней - можно объединить
wdays = [item for sublist in work_weeks for item in sublist]
print(wdays)   # [1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 15, 16, 17, 18, 19, 22, 23, 24, 25, 26, 29, 30, 31]

Можно убрать выходные еще более изящно, используя только индексы:
# Формируем список дней от 1 до 31 с которым будем работать
days = [d for d in range(1, 32)]

wdays6 = [wd for (i, wd) in enumerate(days, 1) if i % 7 != 0]  # Удаляем каждый 7-й день
# Удаляем каждый 6 день в оставшихся после первого удаления:
wdays5 = [wd for (i, wd) in enumerate(wdays6, 1) if i % 6 != 0]

print(wdays5)
# [1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 15, 16, 17, 18, 19, 22, 23, 24, 25, 26, 29, 30, 31]

# Обратите внимание, что просто объединить два условия в одном if не получится,
# как минимум потому, что 12-й день делится на 6, но не выпадает на последний 2 дня недели!

# Шикарное короткое решение:
days = [d + 1 for d in range(31) if d % 7 < 5]
&py/


	Работа с модулями
1. Способы подключить модуль:

Вариант 1
import название

Вариант 2
from название import *

Вариант 3
from название import название1, название2, ...

Вариант 4
import название as новое_название

Вариант 5
from название import название1 as новое_название1, название2 as новое_название2, ...

В чём разница:
1. Когда мы подключаем модуль с помощью import мы не вываливаем всё пространство имён в программу. Чтобы обратиться к его содержимому нужно будет использовать следующую схему:
название.что_то

2. Когда мы используем from, то мы вываливаем то, что нам нужно из модуля прямо в программу. Если так делать много, образуется свалка в единой программе. В данном случае мы сможем обращаться к содержимому модулю просто:
что_то



	Модуль collections
Модуль, предоставляющий ещё коллекции

	Counter
Словаре-подобная коллекция. Содержит неизменяемые элементы в виде элемент: количество

Как создать:
1. На основе другой коллекции:
/&py
import collections
counter = collections.Counter(collection)  # collection  --  коллекция, содержащая неизменяемые элементы
&py/

2. Заполнив пустой Counter:
/&py
import collections
c = collections.Counter()
for word in ['spam', 'egg', 'spam', 'counter', 'counter', 'counter']:
    c[word] += 1
&py/

3. Инициализировав Counter:
/&py
import collections
c = collections.Counter(a=4, b=2, c=0, d=-2)
&py/

Что можно делать с коллекцией:
1. Функция elements()  --  возвращает список элементов в лексикографическом порядке
/&py
from collections import Counter
c = Counter(a=4, b=2, c=0, d=-2)
list(c.elements())  # ['a', 'a', 'a', 'a', 'b', 'b']
&py/

2. Функция most_common([n])  --  возвращает n наиболее часто встречающихся элементов, в порядке убывания встречаемости. Если n не указано, возвращаются все элементы
/&py
from collections import Counter
Counter('abracadabra').most_common(3)  # [('a', 5), ('r', 2), ('b', 2)]
&py/

3. Функция subtract([iterable-or-mapping])  --  вычитание
/&py
from collections import Collections

c = Counter(a=4, b=2, c=0, d=-2)
d = Counter(a=1, b=2, c=3, d=4)
c.subtract(d)  # Counter({'a': 3, 'b': 0, 'c': -3, 'd': -6})
&py/

Наиболее часто употребляемые шаблоны для работы с Counter:

sum(c.values()) - общее количество
c.clear() - очистить счётчик
list(c) - список уникальных элементов
set(c) - преобразовать в множество
dict(c) - преобразовать в словарь
c.most_common()[:-n:-1] - n наименее часто встречающихся элементов
c += Counter() - удалить элементы, встречающиеся менее одного раза

Counter также поддерживает сложение, вычитание, пересечение и объединение:
from collections import Counter

/&py
c = Counter(a=3, b=1)
d = Counter(a=1, b=2)
c + d  # Counter({'a': 4, 'b': 3})
c - d  # Counter({'a': 2})
c & d  # Counter({'a': 1, 'b': 1})
c | d  # Counter({'a': 3, 'b': 2})
&py/

Нахрена:
Без понятия. В python обожают синтаксический сахар. Но в некоторых задачах очень уменьшает количество кода. Например даётся текст и нужно вывести самые часто встречающиеся слова:

/&py
text = ...
for old_char in '.', ',', '!', '?', ' "', '" ', " '", "' ":
	text = text.replace(old_char + " ", ' ')
for old_char in ' "', '\n', " '":
	text = text.replace(old_char, ' ')

words = Counter(map(lambda x: x.lower(), text.split(' ')))

print(words.most_common(5))
&py/

А ведь без Counter-а пришлось бы переписать код следующим образом:

/&py
text = ...

for old_char in '.', ',', '!', '?', ' "', '" ', " '", "' ":
	text = text.replace(old_char + " ", ' ')
for old_char in ' "', '\n', " '":
	text = text.replace(old_char, ' ')

words = Counter(map(lambda x: x.lower(), text.split(' ')))

print(words.most_common(5))


for old_char in '.', ',', '!', '?':
	text = text.replace(old_char, '')

words = list(map(lambda x: x.lower(), text.split(' ')))
just_words = set(words)
count_word = []

for word in just_words:
	count_word.append((words.count(word), word))

count_word.sort(reverse=True)

print(list(map(lambda x: tuple(reversed(x)), count_word[:5])))
&py/

Работающий код в папке full code в папке Counter Examples файле example1.py


	deque
collections.deque(iterable, [maxlen]) - создаёт очередь из итерируемого объекта с максимальной длиной maxlen. Очереди очень похожи на списки, за исключением того, что добавлять и удалять элементы можно либо справа, либо слева

Методы, определённые в deque:

1. append(x) - добавляет x в конец

2. appendleft(x) - добавляет x в начало

3. clear() - очищает очередь

4. count(x) - количество элементов, равных x

5. extend(iterable) - добавляет в конец все элементы iterable

6. extendleft(iterable) - добавляет в начало все элементы iterable (начиная с последнего элемента iterable)

7. pop() - удаляет и возвращает последний элемент очереди

8. popleft() - удаляет и возвращает первый элемент очереди

9 remove(value) - удаляет первое вхождение value

10. reverse() - разворачивает очередь

11. rotate(n) - последовательно переносит n элементов из конца в начало (если n отрицательно, то с начала в конец)

	defaultdict
defaultdict ничем не отличается от обычного словаря за исключением того, что по умолчанию всегда вызывается функция, возвращающая значение:

/&py
import collections
defdict = collections.defaultdict(list)
print(defdict)  # defaultdict(<class 'list'>, {})
for i in range(5):
    defdict[i].append(i)

print(defdict)  # defaultdict(<class 'list'>, {0: [0], 1: [1], 2: [2], 3: [3], 4: [4]})
&py/

То есть он для каждого элемента применил функцию list, перед тем, как добавлять его в словарь

	OrderedDict
OrderedDict - ещё один похожий на словарь объект, но он помнит порядок, в котором ему были даны ключи

Методы:

1. popitem(last=True) - удаляет последний элемент если last=True, и первый, если last=False.

2. move_to_end(key, last=True) - добавляет ключ в конец если last=True, и в начало, если last=False.

/&py
d = {'banana': 3, 'apple':4, 'pear': 1, 'orange': 2}
OrderedDict(sorted(d.items(), key=lambda t: t[0]))  # OrderedDict([('apple', 4), ('banana', 3), ('orange', 2), ('pear', 1)])
OrderedDict(sorted(d.items(), key=lambda t: t[1]))  # OrderedDict([('pear', 1), ('orange', 2), ('banana', 3), ('apple', 4)])
OrderedDict(sorted(d.items(), key=lambda t: len(t[0])))  # OrderedDict([('pear', 1), ('apple', 4), ('orange', 2), ('banana', 3)])
&py/

	namedtuple
Класс namedtuple позволяет создать тип данных, ведущий себя как кортеж, с тем дополнением, что каждому элементу присваивается имя, по которому можно в дальнейшем получать доступ:

/&py
Point = namedtuple('Point', ['x', 'y'])
p = Point(x=1, y=2)
p  # Point(x=1, y=2)
p.x  # 1
p[0]  # 1
&py/

	ChainMap
ChainMap – это класс, который дает возможность объединить несколько сопоставлений вместе таким образом, чтобы они стали единым целым. Если вы обратитесь к документации, то увидите, что данный класс принимает **maps*

Это значит, что ChainMap будет принимать любое количество сопоставлений или словарей и превращать их в единое обновляемое представление. Примеры лежат в full code в ChainMap Examples в example1.py и example2.py

Конечно в collections ещё что-то валяется, но мы не будем этого рассматривать в данном курсе

	itertools
Модуль itertools - сборник полезных итераторов

1. itertools.count(start=0, step=1) - бесконечная арифметическая прогрессия с первым членом start и шагом step

2. itertools.cycle(iterable) - возвращает по одному значению из последовательности, повторенной бесконечное число раз

3. itertools.repeat(elem, n=Inf) - повторяет elem n раз

4. itertools.accumulate(iterable) - аккумулирует суммы

5. accumulate([1,2,3,4,5]) --> 1 3 6 10 15

6. itertools.chain(*iterables) - возвращает по одному элементу из первого итератора, потом из второго, до тех пор, пока итераторы не кончатся

7. itertools.combinations(iterable, [r]) - комбинации длиной r из iterable без повторяющихся элементов

combinations('ABCD', 2) --> AB AC AD BC BD CD

8. itertools.combinations_with_replacement(iterable, r) - комбинации длиной r из iterable с повторяющимися элементами

combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

9. itertools.compress(data, selectors) - (d[0] if s[0]), (d[1] if s[1]), ...

compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

10. itertools.dropwhile(func, iterable) - элементы iterable, начиная с первого, для которого func вернула ложь

dropwhile(lambda x: x < 5, [1,4,6,4,1]) --> 6 4 1

11. itertools.filterfalse(func, iterable) - все элементы, для которых func возвращает ложь

12. itertools.groupby(iterable, key=None) - группирует элементы по значению. Значение получается применением функции key к элементу (если аргумент key не указан, то значением является сам элемент)

Смотри full code -> groupby -> example1.py

13. itertools.islice(iterable[, start], stop[, step]) - итератор, состоящий из среза

14. itertools.permutations(iterable, r=None) - перестановки длиной r из iterable

15. itertools.product(*iterables, repeat=1) - аналог вложенных циклов

product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy

16. itertools.starmap(function, iterable) - применяет функцию к каждому элементу последовательности (каждый элемент распаковывается)

starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

17. itertools.takewhile(func, iterable) - элементы до тех пор, пока func возвращает истину

takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

18. itertools.tee(iterable, n=2) - кортеж из n итераторов

19. itertools.zip_longest(*iterables, fillvalue=None) - как встроенная функция zip, но берет самый длинный итератор, а более короткие дополняет fillvalue

zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-


		Введение в HTML
**Пояснительная бригада: все термины, которые я буду вводить можно будет посмотреть в information/terminology/html/
	Что такое HTML?
1. HTML расшифровывается, как Hyper Text Markup Language (Язык ГиперТекстовой Разметки)
2. HTML стандартный язык для создания Веб-страниц
3. HTML описывает структуру Веб-страницы
4. HTML состоит из серий элементов
5. HTML элементы говорят браузеру, как отображать контент
6. HTML элементы обозначают частицы контента, такие как "это заголовок", "это параграф", "это ссылка" и т.д.

Смотри full code/html/1/
Простой HTML документ
/&html
<!DOCTYPE html>
<html>
<head>
<title>Page Title</title>
</head>
<body>

<h1>My First Heading</h1>
<p>My first paragraph.</p>

</body>
</html>
&html/

Объяснение простого HTML документа
1. <!DOCTYPE html> декларация определяющая, что это документ формата HTML5
2. <html> элемент  --  это корневой элемент HTML страницы
3. <head> элемент содержит мета информацию об HTML странице
4. <title> элемент указывает название HTML страницы (оно отображается на вкладке сверху)
5. <body> элемент определяет тело документа и является контейнером для всего видимого контента, такого как заголовки, параграфы, картинки, гиперссылки, таблицы, списки и т.д.
6. <h1> элемент определяет огромный заголовок
7. <p> элемент определяет параграф


	Что такое HTML элемент?
HTML элемент определяется открывающим тэгом, каким-то контентом и закрывающим тэгом

<tagname>здесь контент...</tagname>

HTML элемент  --  это всё от открывающего тэга до закрывающего тэга

/&html
<h1>My First Heading</h1>
<p>My first paragraph.</p>
&html/

Открывающий тэг          Контент          Закрывающий тэг
    <h1>             My First Heading          </h1>
    <p>              My first paragraph        </p>
    <br>                  none                 none

Заметка: Некоторые HTML элементы не имеют контента (например элемент <br>). Такие элементы называются пустыми элементами. Пустые элементы не имеют закрывающего тэга!


	Веб браузеры
Основная задача Веб браузера  --  это читать и корректно отображать HTML документы

Веб браузер не отображает HTML тэги, но использует их, чтобы определить, как показывать документ

Смотри картинку 1


	Структура HTML страницы

Смотри картинку 2


	История HTML
1989 Тим Бёрнер-Ли изобрёл WWW
1991 Тим Бёрнер-Ли изобрёл HTML
1993 Дейв Рэггет составил HTML+
1995 Группа работающая над HTML определила HTML 2.0
1997 Рекомендация W3C: HTML 3.2
1999 Рекомендация W3C: HTML 4.01
2000 Рекомендация W3C: XHTML 1.0
2008 WHATWG HTML5 Первый открытый проект
2012 WHATWG HTML5 Живой стандарт
2014 Рекомендация W3C: HTML5
2016 Рекомендация кандидата W3C: HTML 5.1
2017 Рекомендация W3C: HTML 5.1 2-ое издание
2017 Рекомендация W3C: HTML 5.2


		Редакторы HTML
1. Для начала нужно открыть текстовый редактор
2. Нужно написать HTML
3. Сохранить HTML файл
4. Открыть страницу в браузере

Заметка: Редактор лучше брать без автодополнения, только с подсветкой синтаксиса


		Основы HTML
	HTML документы
1. Все HTML документы должны начинаться с декларации типа документа: <!DOCTYPE html>

2. Сам HTML документ начинается с тэга <html> и заканчивается на тэге </html>

3. Видимая часть HTML документа заключена между тэгами <body> и </body>

	<!DOCTYPE> декларация
<!DOCTYPE> декларация представляет тип документа и помогает браузерам отображать веб страницы наиболее корректно

Эта декларация должна появиться во всём документе только раз  --  в самом верху страницы перед какими-либо HTML тэгами

Декларация <!DOCTYPE> не чувствительна к регистру

Декларация для HTML5 выглядит следующим образом:
<!DOCTYPE html>


	HTML Заголовки
HTML заголовки определяются с помощью тэгов с <h1> по <h6>
-- <h1> определяет самый важный заголовок
-- <h6> определяет наименее важный заголовок

Смотри full code/html/3


	HTML Параграфы
HTML параграфы определяются тэгом <p>


	HTML Ссылки
HTML ссылки определяются элементом <a>
-- К ссылкам с помощью атрибута href прикрепляется ссылка

-- Ссылки на внешние веб ресурсы определяются полным доменным именем или ip адресом
-- Ссылки на внутренние элементы определяются с помощью #название_соответствующего_id
-- Ссылки на смежные страницы определяются относительным путём

Смотри full code/html/3


	HTML Картинки
HTML картинки определяются с помощью тэга <img>
-- Источник определяется с помощью атрибута src
-- Альтернативный текст определяется с помощью атрибута alt
-- Ширина и высота предоставлены, как атрибуты width и height

Смотри full code/html/4


	Как посмотреть HTML ресурс
Нажать правую кнопку мыши в браузере и выбрать просмотр исходного кода
-- В Google Chrome есть варианты с переходом в новую страницу и с открытием окна справа
-- В Google Chrome сочетание клавиш ctrl+u откроет HTML и CSS код в новой вкладке
-- В Google Chrome сочетание клавиш ctrl+shift+i откроет HTML и CSS код справа в окне


		HTML Элементы
	HTML Элементы
--HTML элементы определяются открывающим тэгом, каким-то контентом и закрывающим тэгом
--HTML элемент - это всё от открывающего тэга и до закрывающего

	Вложенные HTML элементы
1. HTML элементы могут быть вложены (т.е. один элемент может содержать в себе другие)
2. Все HTML документы состоят из вложенных HTML элементов

Следующий пример содержит 4 HTML элемента(<html>, <body>, <h1>, <p>):
/&html
<!DOCTYPE html>
<html>
<body>

<h1>My First Heading</h1>
<p>My first paragraph.</p>

</body>
</html>
&html/

Объяснение примера:
<html> элемент  --  корневой элемент и он определяет весь документ.
Он имеет открывающий тэг <html> и закрывающий тэг </html>.
Затем, внутри <html> элемента есть элемент <body>

/&html
<body>

<h1>My First Heading</h1>
<p>My first paragraph.</p>

</body>
&html/

<body> элемент определяет тело документа.
Он имеет открывающий тэг <body> и закрывающий тэг </body>.
Затем, внутри элемента <body> есть элементы <h1> и <p>

/&html
<h1>My First Heading</h1>
<p>My first paragraph.</p>
&html/

<h1> элемент определяет заголовок.
Он имеет открывающий тэг <h1> и закрывающий тэг </h1>

/&html
<h1>My First Heading</h1>
&html/

<p> элемент определяет параграф.
Он имеет открывающий тэг <p> и закрывающий тэг </p>

/&html
<p>My first paragraph.</p>
&html/
	
	Никогда не пропускай закрывающий тэг
Некоторые HTML элементы будут отображаться корректно, даже если ты забудешь закрывающий тэг
/&html
<html>
<body>

<p>This is a paragraph
<p>This is a paragraph

</body>
</html>
&html/

ОДНАКО НИКОГДА НЕ ПОЛАГАЙСЯ НА ЭТО! НЕОЖИДАННЫЕ РЕЗУЛЬТАТЫ И ОШИБКИ МОГУТ ВОЗНИКНУТЬ ЕСЛИ ТЫ ЗАБУДЕШЬ ЗАКРЫВАЮЩИЙ ТЭГ

	Пустые HTML элементы
HTML элементы, которые не могут иметь контента называются пустыми HTML элементами

Элемент <br> определяет возврат каретки(перевод строки или же 'enter') и является пустым элементом без закрывающего тэга:
/&html
<p>This is a <br> paragraph with a line break.</p>
&html/

	HTML не восприимчив к регистру
HTML тэги не чувствительны к регистру: <P> и <p> значат одно и то же.

Стандарт HTML не требует тэгов, написанных в нижнем регистре, но W3C РЕКОМЕНДУЕТ нижний регистр в HTML и ТРЕБУЕТ нижний регистр для более строгих типов документов, таких как XHTML

Заметка: В процессе обучения я буду придерживаться соглашения о нижнем регистре для имён тэгов

	HTML описание тэгов
В процессе обучения для справки по тэгам можно использовать следующий ресурс: https://www.w3schools.com/tags/default.asp


		HTML атрибуты
HTML атрибуты предоставляют дополнительную информацию об HTML элементах.
	
	HTML атрибуты
1. Все HTML элементы могут иметь атрибуты
2. Атрибуты предоставляют дополнительную информацию об элементах
3. Атрибуты всегда указываются в начальном тэге
4. Атрибуты обычно используются в парах имя/значение, например: name="value"

	Атрибут href
Тэг <a> определяет гиперссылку. Атрибут href указывает URL путь к странице, куда должна вести эта ссылка:
/&html
<a href="https://www.w3schools.com">Visit W3Schools</a>
&html/

	Атрибут src
Тэг <img> используется для вставки картинки на HTML страницу. src атрибут указывает путь к отображаемой картинке:
/&html
<img src="img_girl.jpg">
&html/

Есть два способа указать путь к картинке:
1. Абсолютный URL: указывается полный путь к конкретному файлу на вебсайте(внешняя картинка) или на компьютере

Например:
/&html
<img src="https://www.w3schools.com/images/img_girl.jpg" />
&html/

Заметка: Внешняя картинка может быть под авторскими правами. Если ты не получишь разрешения на её использование, у тебя могут возникнуть проблемы. В дополнении, ты не можешь контролировать внешние картники

2. Относительный URL: ведёт к картинке, которая есть на самом вебсайте. В данном случае путь не включает доменное имя. Если URL начинается без слэша, то путь вычисляется относительной расположения данной страницы. Если URL путь начинается с /, то путь начинается с доменного имени

Например:
/&html
<img src="img_girl.jpg" />
<img src="/images/img_girl.jpg" />
&html/

Заметка: Лучше использовать относительные URL. Они не сломаются при смене домена

	Атрибуты width и height
width  --  ширина картинки
height  --  высота картинки

Если указаны оба, то картинка растягивается/сжимается
Если один отсутствует, второй вычисляется относительно размеров оригинальной картинки
Если оба отсутствуют, подставляются оригинальные значения картинки

Например:
/&html
<img src="doggo.gif" width="400" height="200" />
<img src="hottu-doggo.jpg" width="1080" />
<img src="hottu-neko.png" height="720" />
<img src="hottu-neko-and-hottu-doggo-full" />
&html/

	Атрибут alt
Необходимый атрибут для тэга img. Указывает текст, который будет отображён, если картинка по каким-то причинам не может быть отображена. Это может случиться в связи с медленным соединением, или ошибкой в атрибуте src, или при использовании screen reader'а

Например:
/&html
<img src="img_girl.jpg" alt="Girl with a jacket">
&html/

	Атрибут style
Этот атрибут используется для стилизации элемента. Он может определять размер, шрифт, цвет текста и т.д.

Например:
/&html
<p style="color: red;">This is a red paragraph</p>
&html/

	Атрибут lang
Этот атрибут стоит всегда включать в тэг <html>, чтобы декларировать язык веб-страницы. Это предназначено для помощи поисковым движкам и браузерам

Следующий пример указывает язык страницы, как Английский:
/&html
<!DOCTYPE html>
<html lang="en">
<body>
...
</body>
</html>
&html/

Также можно добавлять коды страны в атрибут lang. Первые две буквы отвечают за язык, последние две  --  за страну

Следующий пример указывает язык, как Английский и страну, как США:
/&html
<!DOCTYPE html>
<html lang="en-US">
<body>
...
</body>
</html>
&html/

	Атрибут title
Этот атрибут определяет некоторую дополнительную информацию, которая отображается при наведении курсора на элемент.

Например:
/&html
<p title="I'm a tooltip">This is a paragraph.</p>
&html/

	Я предлагаю: Всегда используй нижний регистр
HTML стандарт не требует нижнего регистра для имён атрибутов.

Атрибут title (и другие) могут быть написаны в верхнем регистре TITLE. 

	Я предлагаю: Всегда заключай значения атрибутов в кавычки
HTML стандарт не требует кавычек вокруг значений атрибутов

Однако W3C рекомендует использовать кавычки и требует их использования для более строгих типов документов. Например XHTML

Хорошо:
/&html
<a href="https://www.w3schools.com/html/">Visit our HTML tutorial</a>
&html/

Плохо:
/&html
<a href=https://www.w3schools.com/html/>Visit our HTML tutorial</a>
&html/

Иногда без кавычек не обойтись вовсе. Например тут:
/&html
<p title=About W3Schools>
&html/

	Одинарные или двойные кавычки?
В основном в ходу двойные, однако также могут быть использованы и одинарные

В некоторых случаях, когда атрибут содержит двойные кавычки, необходимо оборачивать его одинарными:
/&html
<p title='John "ShotGun" Nelson'>
&html/

И наоборот:
/&html
<p title="John 'ShotGun' Nelson">
&html/

	
		HTML Заголовки
HTML заголовки являются заголовками и подзаголовками, которые ты хочешь отобразить на веб странице

	HTML Заголовки
HTML заголовки определяются тэгами с <h1> по <h6>

<h1>  --  Самый важный тэг, а <h6>  --  самый неважный

Например:
/&html
<h1>Heading 1</h1>
<h2>Heading 2</h2>
<h3>Heading 3</h3>
<h4>Heading 4</h4>
<h5>Heading 5</h5>
<h6>Heading 6</h6>
&html/

Заметка: Браузеры автоматически добавят отступ(some white space(a margin)) перед и после заголовка
	
	Заголовки важны
Поисковые движки используют заголовки, чтобы индексировать структуру и контент твоей страницы

Пользователи часто просматривают страницу по её заголовкам. Важно их использовать, чтобы показать структуру страницы

<h1> стоит использовать для самого важно заголовка. Далее для иерархии следует использовать <h2>, затем <h3> и т.д.	

Заметка: Не используй заголовки, чтобы сделать текст большим или жирным

	Увеличенные заголовки
У каждого HTML заголовка есть свой начальный размер. Его можно поменять используя свойство font-size у атрибута style

/&html
<h1 style="font-size:60px;">Heading 1</h1>
&html/

		HTML Параграфы
Параграф всегда начинается с новой строки и обычно является блоком текста

	HTML Параграфы
HTML элемент <p> определяет параграф

Параграф всегда начинается с новой строки и браузеры всегда добавляют немного отступа (white space (margin)) перед и после параграфа

/&html
<p>This is a paragraph.</p>
<p>This is another paragraph.</p>
&html/

	HTML Отображение
Ты не можешь быть уверена, как отображён HTML

Большие или маленькие экрана, изменение размера окна создадут разные результаты

С помощью HTML ты не можешь добавлять дополнительные пробелы или дополнительные линии в HTML код

Браузеры автоматически удалят все дополнительные пробелы и линии, когда страница отображается
/&html
<p>
This paragraph
contains a lot of lines
in the source code,
but the browser
ignores it.
</p>

<p>
This paragraph
contains         a lot of spaces
in the source         code,
but the        browser
ignores it.
</p>
&html/

	HTML Горизонтальные правила(horizontal rule)
Тэг <hr> определяет тематический обрыв в HTML странице и наиболее часто отображается, как горизонтальная линия

Элемент <hr> используется для разделения контента(или определения перемены) в HTML странице:

/&html
<h1>This is heading 1</h1>
<p>This is some text.</p>
<hr>
<h2>This is heading 2</h2>
<p>This is some other text.</p>
<hr>
&html/

<hr>  --  это пустой тэг, что означает, что у него нет закрывающего тэга

	HTML Перевод/разрыв строки(line break)
HTML элемент <br> определяет перевод строки

Используй тэг <br>, если тебе нужна новая линия(перевод строки) без начала новой строки

/&html
<p>This is<br>a paragraph<br>with line breaks.</p>
&html/

<br>  --  это пустой тэг, что означает, что у него нет закрывающего тэга

	Проблема поэмы
Это поэма будет отображена на одной строчке:

/&html
<p>
  My Bonnie lies over the ocean.

  My Bonnie lies over the sea.

  My Bonnie lies over the ocean.

  Oh, bring back my Bonnie to me.
</p>
&html/

	Решение  --  HTML элемент <pre>
HTML тэг <pre> определяет предварительно отформатированный текст

Текст внутри элемента <pre> отображается в шрифте фиксированной ширины(обычно Курьер(Courier)) и он сохраняет и пробели и переводы строки внутри текста:

/&html
<pre>
  My Bonnie lies over the ocean.

  My Bonnie lies over the sea.

  My Bonnie lies over the ocean.

  Oh, bring back my Bonnie to me.
</pre>
&html/

Смотри full code/html/7/


		Введение в реляционные базы данных
	Что такое реляционная база данных?
БД  --  база данных
СУБД  --  система управления базой данных
Реляционная БД  --  связанная информация, представленная в виде двумерных таблиц
Запись  --  строка в таблице


Пример БД:
Name                 Telephone          Address
Gerry Farish       (415) 365-8775     127 Primrose Ave., SF
Celia Brock        (707) 874-3553     246 #4 3rd St., Sonoma
Yves Grillet       (762) 976-3665     778 Modernas, Barcelona

	Связь между таблицами
Если у тебя есть одна таблица с посетителями больницы и их врачами и вторая таблица с теми же посетителями, но уже их номерами, то мы можем найти во второй таблице телефон человека с лечащим врачом из первой таблицы

	Порядок строк произволен
Для обеспечения гибкости, порядок строк произволен. Поэтому запрашивать 5 запись таблицы логически неверно

	Идентификация строк(первичный ключ)
Первичный ключ(primary key)  --  уникальный столбец, используемый для идентификация каждой строки и обеспечивающий различимость всех строк

По ряду причин необходимо иметь столбец таблицы, который однозначно идентифицирует каждую строку(например если два Павла возрастом 45 и вес 76). Обычно этот столбец содержит номер. Такой столбец и называется первичным ключом(primary key)

	Столбцы поименованы и пронумерованы
Поле  -- столбец в таблице


		Введение в SQL
	Как работает SQL
SQL  --  это язык, ориентированный специально на базы реляционные базы данных

Он позволяет исключить большую часть работы языка общего назначения(например python). Для создания БД на python с нуля пришлось бы начать с определения, а что такое таблица, а что такое строка и т.д. А для поиска информации нужно было бы реализовать данный алгоритм:
1. Посмотреть очередную строку таблицы
2. Оттестировать её и убедиться, что это именно та строка, которая тебя интересует
3. Запомнить эту строку до тех пор, пока не будет просмотрена вся таблица
4. Определить есть ли в таблице ещё строки
5. Если в таблице есть ещё строки(просмотрены не все строки), то вернуться к шагу 1
6. Если в таблице больше нет строк(просмотрены все строки таблицы), вывести все значения, полученные на третьем этапе

SQL освобождает от данной работы. Команды SQL могут выполняться над целой группой таблиц, как над единым объектом, а также могут оперировать любым количеством информации, которая извлекается или выводится из них, как из единого целого

	Как осуществляется связь с ANSI-таблицей
Стандарт SQL определён ANSI(American National Standards Institute). SQL  --  продукт исследований IBM, а не изобретение ANSI

Однако на рынке далеко не все придерживаются этого стандарта и реализации баз данных на основе SQL могут сильно отличаться и иногда отходить от общего стандарта(например MySQL, SQLite, Oracle SQL, ...)

ANSI  --  это своего рода минимальный стандарт

	Интерактивная версия встроенного SQL
Существует два SQL: интерактивный и встроенный. Они работают в целом одинаково, но используются по-разному

Интерактивный SQL используется для выполнения действий в самой базе данных и который будет использоваться человеком. В такой форме команда вводится, выполняется, после чего можно немедленно увидеть выходные данные(если такие есть)

Встроенный SQL состоит из команд, написанных чаще всего на другом языке(python, java, c++). Такое включение может сделать программу более мощной и эффективной. Однако несовместимость этих ЯП-ов со структурой SQL требует ряда расширений. Выходные данные команд SQL во встроенном SQL "заносятся" в переменные или параметры, используемые программой

Мы по большей части будем работать в интерактивной среде, а в конце коснёмся реализации на python'е

	Подразделы SQL
В обоих SQL(интерактивном и встроенном) имеется множество секций или подразделов. В процессе освоения SQL мы будем придерживаться этой терминологии, однако неудачным является то, что эти термины используются не всегда и не во всех реализациях SQL. Они полезны на концептуальном уровне и выделяются ANSI, но во многих продуктах они практически не выделены и поэтому стали функциональными категориями команд

DDL(data definition language)  --  состоит из тех команд, которые создают объекты(таблицы, индексы, представления) в БД
SDL(schema definition language)  --  то же, что и DDL
DML(data manipulation language)  --  множество команд, определяющих, какие данные представлены в таблицах в любой момент времени
DCL(data control language)  --  состоит из предложений, определяющих, может ли пользователь выполнить определённое действие

Согласно ANSI DCL является частью DDL, но важно не путать эти названия. Речь идёт не о различных языках, как таковых, а о разделах, сгруппированных по их функциональному назначению


	Различные типы данных
Не все типы данных, содержащиеся в полях таблицы являются логически одинаковыми. Например числа  --  это не строки

В SQL каждому полю приписывается тип данных(data type). Все значения для данного поля должны быть одним типом

Определение этих типов данных является той областью в которой коммерческие СУБД и официальный SQL имеют существенные различия. Стандарт ANSI SQL распознаёт только текстовый и числовой типы, тогда как многие коммерческие СУБД используют и другие специальные типы. Заметим, что типы DATE(дата) и TIME(время) почти de-facto являются стандартными(хотя конкретные их форматы отличаются). Некоторые СУБД поддерживают такие типы данных, как MONEY(деньги) и BINARY(двоичный)

ANSI определяет несколько различных типов числовых значений.

Типы ANSI:
			ТЕКСТ
CHAR (или CHARACTER) Строка текста в реализационно-определенном формате. Размер аргумента здесь это единственное неотрицательное целое число, которое ссылается к максимальной длине строки. Значения этого типа, должны быть заключены в одиночные кавычки, например 'text'. Две рядом стоящие одиночные кавычки ('') внутри строки будет пониматься как одна одиночная кавычка (')

ПРИМЕЧАНИЕ: Здесь и далее, фраза Реализационно-Определенный или Реализационно-Зависимый, указывает, что этот аргумент или формат зависит от конкретной программы, в которой реализуются данные

			ТОЧНОЕ ЧИСЛО
DEC (или DECIMAL) Десятичное число; то есть, число которое может иметь десятичную точку. Здесь аргумент размера имеет две части: точность и масштаб. Масштаб не может превышать точность. Сначала указывается точность, разделительная запятая и далее аргумент масштаба. Точность указывает сколько значащих цифр имеет
число. Максимальное десятичное число составляющее номер — реализационно-определенное значение, равное или большее
чем этот номер. Масштаб указывает максимальное число цифр справа от десятичной точки. Масштаб = 0 делает поле эквивалентом целого числа

NUMERIC Такое же как DECIMAL за исключением того, что максимальное десятичное не может превышать аргумента точности.

INT (или INTEGER) Число без десятичной точки. Эквивалентно DECIMAL, но без цифр справа от десятичной точки, то есть с масштабом равным 0. Аргумент размера не используется (он автоматически устанавливается в реализационно-зависимое значение).

SMALLINT Такое же как INTEGER, за исключением того, что, в зависимости от реализации, размер по умолчанию может (или не может) быть меньшее чем INTEGER.

			ПРИБЛИЗИТЕЛЬНОЕ ЧИСЛО
FLOAT Число с плавающей запятой на основе 10 показательной функции. Аргумент размера состоит из одного числа определяющего минимальную точность.

REAL Такое же как FLOAT, за исключением того, что никакого аргумента размера не используется. Точность установлена реализационно-зависимую по умолчанию.

DOUBLE PRECISION Такое же как REAL, за исключением того, что (или DOUBLE) реализационно-определяемая точность для DOUBLE

PRECISION должна превышать реализационно определяемую точность REAL



	Формирование запроса
SQL  --  structured query language(структурированный язык запросов)
Запрос  --  команда СУБД, требующая предоставить указанную инфу

Запрос является часть DML, но не изменяет информацию, а только показывает её

Все запросы конструируются на базе одной команды SELECT

Теперь и далее я почти всегда буду использовать эту БД:


	Salespeople
snum       sname       city       comm

1001        Peel      London      0.12
1002       Serres    San Jose     0.13
1003       Axelrod   New York     0.10
1004       Motika     London      0.11
1007       Rifkin    Barcelona    0.15

	Orders
onum       amt       odate       cnum       snum

3001      18.69    1990-03-10    2008       1007
3002      1900.1   1990-03-10    2007       1004
3003      767.19   1990-03-10    2001       1001
3005      5160.45  1990-03-10    2003       1002
3007       75.75   1990-04-10    2004       1002
3008       4723    1990-05-10    2006       1001
3009      1713.23  1990-04-10    2002       1003
3010      1309.95  1990-06-10    2004       1002
3011      9891.88  1990-06-10    2006       1001

	Customers
cnum       cname       city       rating       snum

2001      Hoffman     London       100         1001
2002      Giovanni     Rome        200         1003
2003        Liu      San Jose      200         1002
2004       Grass      Berlin       300         1002
2006      Clemens     London       100         1001
2007      Pereira      Rome        100         1004
2008      Cisneros   San Jose      300         1007

















