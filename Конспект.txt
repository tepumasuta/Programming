
Конспект

		1. Что такое языки программирования и какие они бывают
ОС  --  операционная система

ЯП  --  язык программирования

Интерпретатор  --  программа, которая сразу пытается выполнить код программы, по мере его поступления
Компилятор  --  программа, которая пытается преобразовать код к исполняемому файлу

Интерпретируемый ЯП  --  ЯП, код которого считывается строчка за строчкой и передаётся по строчке интерпретатору. Интерпретатор пытается сразу же выполнить код

Интерактивный режим  --  процесс написания кода, когда человек пишет код и он сразу же выполняется

Компилируемый ЯП  -- ЯП, код которого заранее анализируется компилятором и преобразуется в код, понятный машине

Плюсы и минусы Интерпретируемых ЯП-ов:
	+++
1. Возможность работы в интерактивном режиме
2. Возможность выполнения кода кусками
3. Кросс-платформенность
4. Рефлексия
5. Динамическая типизация
6. Меньший размер исполняемых файлов
7. Динамические области видимости

	---
1. Медленная скорость работы
2. Кросс-платформенность

Плюсы и минусы Компилируемых ЯП-ов:
	+++
1. Скорость
2. Контроль
3. Управление памятью
4. Управление процессором
5. Платформо-зависимость

	---
1. Платформо-зависимость
2. Сложность отладки
3. Компиляция

Кросс-платформенность  --  возможность выполнения кода на разных операционных системах. Например Linux и Windows

Платформо-зависимость  --  невозможность выполнения кода на разных платформах

Рефлексия  --  самоанализ

Исполняемые файлы  --  файлы, код которых умеет выполнять операционная система. В windows это файлы с расширением .exe

	Типизация языков
1. динамическая/статическая
2. явная/неявная
3. сильная/слабая

Динамическая типизация  --  тип переменной определяется при выполнении программы
Статическая типизация  --  тип переменной определяется на этапе компиляции программы

Явная типизация  --  при объявлении переменной необходимо указывать её тип
Неявная типизация  --  при объявлении переменной не нужно указывать её тип

Сильная типизация  --  нельзя производить операции в выражениях с данными различных типов
Слабая типизация  --  можно производить операции в выражениях с данными различных типов


Python  --  обладает сильной неявной динамической типизацией


	Стандартная библиотека python
Стандартная библиотека python  --  это набор всех подключаемых модулей, которые поставляются вместе с интерпретатором

Модуль  --  функционально законченный фрагмент программы, оформленный в виде отдельного файла с исходным кодом или поименованной непрерывной её части

Основные модули:
sys, os, math, time


	IDE и редакторы кода
IDE  --  Integrated development enviroment(интегрированная среда разработки)

IDE  --  приложение, помогающее разработчику писать код, обладающее полезными функциями. Например анализ кода, подсветка синтаксиса, подсветка ошибок, поиск, возможность работы с проектами и т.д. Очень мощный инструмент

Редактор кода  --  приложение, позволяющее разработчику писать код. Обладает много меньшим набором полезных функций. В основном это подстветка синтаксиса

Основные IDE для python:
PyCharm, Visual Studio, Spyder, Eclipse

Основные редакторы кода для python:
Notepad++, Vim, Sublime Text 3


	Работа из консоли
ПО  --  программное обеспечение

Консоль  --  Интерфейс пользователя, окно для вывода системных сообщений и приёма команд
Консоль  --  ПО, реализующее текстовый интерфейс пользователя.



Аргументы командной строки  --  строки, передаваемые после основной команды при вызове команды

Чтобы открыть консоль нужно в строку поиска ввести cmd


Основные команды консоли:
help, cd, cls, mkdir

help  --  если не передать аргументов, выводит базовую подсказку. Если передать аргумент, то выводит подробную информацию о нём

cd  --  переход в каталог, указанный аргументом. Можно указать, как абсолютный, так и относительный путь

cls  --  очищает консоль

mkdir  --  создаёт каталог, указанный относительным или абсолютным путём в качестве аргумента


Чтобы запустить программу на языке python из консоли нужно написать python и в качестве аргументов передать абсолютный или относительный путь к файлы. Можно передать, как в двойных кавычках, так и без

Чтобы войти в интерактивный режим нужно прописать python без аргументов. Чтобы выйти из него необходимо прописать exit()

Основы работы в интерактивном режиме

Если просто написать какое-либо значение, то python его выведет. Если передать выражение, то он выведет его результат

Если прописать функцию help и передать в качестве аргумента какую-то функцию, то он выведет всё, что о ней знает. Если вызвать функцию help без аргументов, то войдёшь в режим help. Ты сможешь сразу писать функцию и он выведет всё, что о ней знает. Чтобы выйти из неё надо просто прописать пустую строку

	
		2. Правила оформления кода
Код нужно оформлять, чтобы другие программисты могли легко прочитать программу и внедрится в проект. Также это необходимо для entreprise-а

Есть следующие стили написания кода:

camelStyle

Пример:
thisIsAnExample


PascalCase

Пример:
ThisIsAnExample


kebab-case

Пример:
this-is-an-example


snake_case

Пример
this_is_an_example


	PEP8
PEP8  --  сбор правил, утверждённый сообществом, объясняющий, как писать код, называть классы, перменные, сколько делать отступом и т.д. и т.п.

Просто слушайся PyCharm и всё будет хорошо. Их не надо заучивать


	Модули
Подходы к написанию кода:

1. Модульный подход  --  это организация программы как совокупности небольших независимых блоков, называемых модулями, структура и поведение которых подчиняются определённым правилам

2. Объектно-ориентрированный подход  --  использует объектную декомпозицию, то есть поведение системы описывается в терминах взаимодействия объектов

3. Функциональный подход к управлению  --  это традиционное делегирование полномочий и определенной ответственности через функции, т. е. такие "подсистемы" организации, которые можно выделить по схожести проводимых работ

Парадигма программирования  --  это совокупность идей и понятий, определяющих стиль написания компьютерных программ


Некоторые парадигмы:
1. Императивное программирование
2. Декларативное программирование
3. Структурное программирование
4. Функциональное программирование
5. Логическое программирование
6. Объектно-ориентированное программирование
7. Структурное программирование
8. Процедурное программирование
9. Аппликативное программирование
10. Обобщённое программирование
11. Доказательное программирование
12. Порождающее программирование
13. Аспектно-ориентированное программирование
14. Агентно-ориентированное программирование
15. Рекурсия
16. Автоматное программирование
17. Событийно-ориентированное программирование
18. Компонентно-ориентированное программирование
19. Грамотное программирование


Иерархическая схема:
Смотри рисунок 0


	Библиотеки и фреймворки
Библиотека  --  сбор функций и модулей, призванный сократить написание однообразного кода. Пользуясь библиотекой в основном код пишешь всё ещё ты

Фреймворк  --  сбор функций, модулей и библиотек, призванный сократить написание однообразного кода. Пользуясь фреймворком в основном код берётся именно оттуда, а ты только добавляешь необходимые детали



		Ссылочная модель данных
Модель данных – это совокупность структур данных и операций их обработки

Инициализация  --  присваивание первоначального значения переменной

Python обладает ссылочной моделью данных. То есть каждая переменная это ссылка. Ссылка указывает на объект в памяти. Объект, в данном случае – это абстракция для представления данных, данные – это числа, списки, строки и т.п. При этом, под данными следует понимать как непосредственно сами объекты, так и отношения между ними. Каждый объект имеет три атрибута – это идентификатор, значение и тип. Идентификатор – это уникальный признак объекта, позволяющий отличать объекты друг от друга, а значение – непосредственно информация, хранящаяся в памяти, которой управляет интерпретатор

Когда мы пишем b = 5, то что происходит на уровне интерпретатора:
1. Создается целочисленный объект 5 (можно представить, что в этот момент создается ячейка и 5 кладется в эту ячейку);
2. Данный объект имеет некоторый идентификатор, значение: 5, и тип: целое число;
3. Посредством оператора связывания '=' создается ссылка между переменной 'b' и целочисленным объектом 5 (переменная 'b' ссылается на объект 5).




	Сборщик мусора
Когда на объект перестают указывать ссылки, его съедает garbage collector. Это удобно, т.к. не приходится самому помнить, что каждый созданный объект нужно уничтожить, иначе он так и будет плавать в памяти

	built-in типы
built-in типы  --  это типы, которые есть в любой программе изначально и не нужно подключать какие-то модули, чтобы ими пользоваться. built-in можно в данном случае перевести, как встроенные

В python существуют следующие built-in типы:

None Type (class NoneType)  --  тип для неопределённого значения переменной. Единственное значение: None
Numeric Type  --  числа
	Integral Type  --  типы, представляющиеся целыми числами:
		Boolean Type (class bool)  --  тип, обозначающий логическое значение. Есть два значения: True, False
		Integer Type (class int)  --  тип, обозначающий целое число
	Real Type (class float)  --  тип, обозначающий десятичные числа
	Complex Type (class complex)  --  тип, обозначающий комплексные числа
Sequence Type  --  типы, представяющие последовательности
	List Type (class list)  --  тип, обозначающий список элементов
	Tuple Type (class tuple)  --  тип, обозначающий неизменяемый список
	Range Type (class range)  --  тип, обозначающий арифметическую прогрессию
Text Sequence Type  --  типы, обозначающие строковые последовательности
	String Type (class str)  --  тип, обозначающий строковые последовательности(строки)
Binary Sequence Type  --  типы, обозначающие бинарные последовательности
	Bytes Type (class bytes)  -- тип, обозначающий последовательность битов
	Bytes Array Type (class bytearray)  --  тип, обозначающий массив битов
	MemoryView Type (class memoryview)  --  тип, не входящий в рамки нашего курса
Set Types  --  множества
	Set Type (class set)  --  тип, обозначающий множество элементов
	Frozen Set Type (class frozenset)  --  тип, обозначающий неизменяемое множество
Mapping Types  --  отображаемые типы
	Dictionary Type (class dict)  --  тип, представляющий словарь, хэш таблицу


Mutable  --  изменяемый
Immutable  --  неизменяемый

Mutable типы  --  это типы, которые могут изменится, не меняя идентификатор. То есть, если имя 'a' и имя 'b' указывали на один и тот же объект, то изменяя его по ссылке 'a' он изменится и по ссылке 'b'

Immutable типы  --  это типы, которые не изменяют сами себя


Immutable built-in типы:
целые числа (int), числа с плавающей точкой (float), комплексные числа (complex), логические переменные (bool), кортежи (tuple), строки (str) и неизменяемые множества (frozen set)

Mutable built-in типы:
списки (list), множества (set), словари (dict)


	Выражения
Выражение(expression)  --  совокупность переменных, констант, знаков операций, имен функций, скобок, которая может быть вычислена в соответствии с синтаксисом языка программирования. Результатом вычисления выражения является величина определенного типа

Когда python встречает выражения, то он начинает его вычислять. Если в него входят операции, то они выполняюся в порядке, который определён для них. Функции вычисляются по мере необходимости

Разберём пример:
a = b + f(g(x) + 7 / 3 ** 4)
Как это воспримет python:
	Как он видит:
	1. =
	2. b
	3. +
	4. f(...)
	5. g(...)
	6. x
	7. +
	8. /
	9. **

	Как он выполнит:
	1. b
	2. x
	3. g(...)
	4. **
	5. /
	6. +
	7. f(...)
	8. +
	9. =


	Полезные функции
print(a)  --  выводит a, где a  --  выражение
input()  --  возвращает строку, считанную с клавиатуры
id(a)  --  возвращает идентификатор объекта, на который указывает имя 'a'
type(a)  --  возвращает тип объекта, с которым связано имя 'a'
len(a)  --  возвращает длину объекта, на который ссылается имя 'a'



	Приведение типов
Типы, это данные. А следовательно можно один тип преобразовать к другому. Например была у тебя валюта в евро, а стала в рублях. А затем купила пылесос. Это называется приведением типов

В общем виде:
класс(объект, ...)

Например, когда мы пишем int(input()), происходит следующее:
1. Пользователь вводит строку
2. Строка приводится к типу int

		3. Числовые типы
Атрибуты/поля/свойства класса  --  переменные, которые хранит каждый объект. Могут быть уникальны для каждого(например значения) и не привязанные к объекту (например значение числа pi)

Классовые функции  --  функции, прописанные в самом классе. Обычно они являются уникальными для каждого класса

Если у классовой функции в качетве аргумента написано self, / , то значит, что она применятся к самому объекту без аргументов

Стурктура использования атрибутов:
объект/класс.атрибут

аргумент/параметр функции  --  то, что передаётся в скобках

ключевой/именованый аргумент/параметр  --  параметр, передающийся только по его имени

Структура использования функции(я здесь немножко вру, но это мы разберём более подробно, когда перейдём к функциям):
имя_функции(обязательный_аргумент1, обязательный_аргумент2, [необязательный_аргумент 1[, необязательынй_аргумент 2...]], именованый_аргумент1=значение1, именованый_аргумент2=значение2)

Примечание
Когда пишут аргументы функции, если часть из них заключена в скобки, то значит, что они необязательны

Функция может быть использована и без аргументов:
print()


	Класс int
Класс int хранит в себе число в десятичной системе счисления. К нему применимы все арифметические операторы. К нему можно привести тип str

В общем виде приведение типа str к типу int выглядит следующим образом:
int(x[, base])  --  x строка, base основание системы счисления. То есть он пытается преобразовать строку из системы счилсения с основанием base к десятичной системе счисления. В случае неудачи  --  ошибка. По умолчанию base = 10

Создание объекта int на основании объекта int:
int([x])  --  x класс int. По умолчанию x = 0

К классу int применима функция abs(x)


Классовые функции:
as_integer_ratio(self, /)  --  возвращает пару целых чисел, дробь из которых равна данному числу
bit_length(self, /)  --  Возращает сколько битов необходимо, чтобы записать данное число в двоичной системе счисления
from_bytes(bytes, byteorder, *, signed=False)  --  собирает число из байтов


	Класс float
Класс float хранит в себе дробное число в десятичной форме. К нему применимы все арифметические операторы. К нему можно привести тип str

В общем виде приведение типа str к типу float выглядит следующим образом
float(x)  --  x строка

Создание объекта float на основании типа float:
float([x])  --  x класс float. По умолчанию x = 0.0

Создание объекта int на основании объекта float:
int(x)  --  x объект класса float. При преведении дробная часть отбрасывается


Классовые функции:
as_integer_ratio(self, /)  --  возвращает пару целых чисел, дробь из которых равна данному числу
conjugate(self, /)  --  возвращает комлексно сопряжённое данному числу
hex(self, /)  --  переводит число в 16-ричную систему счисления
is_integer(self, /)  --  возвращает правду, если число является целочисленным
fromhex(string, /)  --  string строка, содержащая дробное число в 16-ричной системе счисления

Отсюда начать
	Класс complex
Класс complex представляет комплексные дробные и целые числа


Создание объекта complex:
complex([x[, y]])  --  x, y целые или дробные числа. По умолчанию x, y = 0. y - комплексаня часть числа, x - действительная часть числа

Атрибуты:
real, imag

Классовые функции:
conjugate()  --  возвращает комлексно сопряжённое данному числу

		
		4. Логический тип
	Класс bool
Класс bool представляет правду или ложь. Является подклассом класса int


Создание объекта класса bool:
bool(x)  --  x объект класса int. Возвращает ложь, если x равен нулю, иначе правда
bool(x)  --  x объект класса float. Возвращает ложь, если x равен нулю, иначе правда
bool(x)  --  x объект класса complex. Возвращает ложь, если дейтсвительная и мнимая часть x равны нулю, иначе правда
bool(x)  --  x объект класса str. Возвращает ложь, если x пустая строка, иначе правда

Принцип следующий: Возвращает правду, если объект является правдой. То есть оно пытается привести объект к классу bool и смотрит на результат

К классу bool могут быть применеы все арифметические операции


		Операторы
Оператор  --  инструкция или оператор — наименьшая автономная часть языка программирования; команда или набор команд

Операнды  --  аргумент операции; данные, которые обрабатываются командой/оператором


Унарные опреторы  --  операторы, принимающие 1 операнд
Бинарные операторы  --  операторы, принимающие 2 операнда
Тернарные операторы  --  опертаоры, принимающие 3 операнда

Операторы в python делятся на:
1. Арифметические операторы
2. Операторы сравнения (реляционные)
3. Операторы присваивания
4. Побитовые операторы
5. Логические операторы
6. Операторы членства (Membership operators)
7. Операторы тождественности (Identity operators)

	Арифметические операторы
Унарные: "+", "-"
	"+"  --  комплиментарный оператор. Его действие выходит за рамки курса
	"-"  --  комплиментарный оператор. От него тебе нужно только знать, что когда ты пишешь -5, "-" это комплиментарный оператор
Бинарные: "+", "-", "*", "/", "%", "**", "//"
	Сложение "+"  --  возвращает сумму двух операндов
	Вычитание "-"  --  возвращает разность двух операндов
	Умножение "*"  --  возвращает произведение двух операндов
	Деление "/"  --  возвращает частное двух операндов, тип всегда float
	Деление по модулю "%"  --  возвращает остаток от деления двух операторов
	Возведение в степень "**"  --  возвращает степень двух операндов
	Целочисленное деление "//"  --  возвращает целую часть частного, тип всегда int

	Операторы сравнения
Бинарные: "==", "!=", ">", "<", ">=", "<="
	Равно "=="  --  проверяет равны ли оба операнда. Если да, то условие становится истинным
	Не равно "!="  --  проверяет равны ли оба операнда. Если нет, то условие становится истинным
	Больше ">"  --  Проверяет больше ли значение левого операнда, чем значение правого. Если да, то условие становится истинным
	Меньше "<"  --  Проверяет меньше ли значение левого операнда, чем значение правого. Если да, то условие становится истинным
	Больше или равно ">="  --  Проверяет больше или равно значение левого операнда, чем значение правого. Если да, то условие становится истинным
	Меньше или равно "<="  --  Проверяет меньше или равно значение левого операнда, чем значение правого. Если да, то условие становится истинным

	Операторы присваивания
Бинарные: "=", "+=", "-=", "*=", "/=", "%=", "**=", "//="
	Оператор связывания "="  --  связывает имя с объектом
	"+="  --  добавить к левому операнду значение правого и запихнуть в левый операнд
	"-="  --  вычесть из левого операнда значение правого и запихнуть в левый операнд
	"*="  --  умножить значение левого операнда на значение правого и запихнуть в левый операнд
	"/="  --  разделить значение левого операнда на значение правого и запихнуть в левый операнд
	"%="  --  найти остаток от деления значения левого операнда на значение правого и запихнуть в левый операнд
	"**="  --  возвести  значение левого операнда в значение правого и запихнуть в левый операнд
	"//="  --  найти целую часть от деления левого операнда на правый и запихнуть в левый операнд

	Побитовые операторы
Основное отличие в том, что они переводят всё в двоичную систему счисления и работают уже в ней. То есть они применяются к каждым двум битам операндов

Унарные: "~"
	Инверсия "~"  --  таблица истинности: "0:1|1:0"
Бинарные: "&", "|", "^", "<<", ">>"
	Побитовое И "&"  --  таблица истинности "0,0:0|1,0:0|0,1:0|1,1:1"
	Побитовое ИЛИ "|"  --  таблица истинности "0,0:0|1,0:1|0,1:1|1,1:0"
	Побитовое исключающее ИЛИ, XOR "^"  --  таблица истинности "0,0:0|1,0:1|0,1:1|1,1:0"
	Побитовый сдвиг влево "<<"  --  дописывает к левому операнду в конец количество нулей, равное второму операнду
	Побитовый сдвиг вправо ">>"  --  стирает у левого операнда количество битов, равное левому операнду

	Логические операнды
Работают только с типом bool, если операнды другого типа, то они преводятся к этому типу

Унарные: "not"
	Не "not"  --  меняет правду на ложь и обратно
Бинарные: "and", "or"
	И "and"  --  возвращает правду, только если оба операнда правда, иначе ложь
	Или "or"  --  возвращает правду, если хотя бы один операнд правда, иначе ложь

	Операторы членства
Бинарные: "in"
	В "in"  --  возвращает правду, если правый операнд содержит левый, иначе ложь

Примечание:
Можно писать not in

	Операторы тождественности
Операторы тождественности сравнивают размещение двух объектов в памяти компьютера

Бинарные: "is"
	Является ли "is"  --  возвращает правду, если оба имени указывают на один и тот же объект. То есть сравнивают id операндов

Примечание:
Можно писать is not


	Таблица приоритетов

**
~ + -  (+, - унарные)  
* / % //
+ -  (+, - бинарные)
>> <<
&
^ |
<= < > >=
<> == !=
= %= /= //= -= += *= **=
is is not
in not in
not or and


		5. Ветвление потока программы
До этого момента все наши программы выглядели следующим образом
Смотри рисунок 2

Теперь мы добавим некоторого разнообразия и программы станут выглядить следующим образом
Смотри рисунок 3

Чтобы отобразить условия есть оператор if. Его общая структура:
Смотри рисунок 4
if условие:
	инструкции
elif условие:
	инструкции
  .
  .
  .
else:
	инструкции

elif и else необязательны

Про отступ:
1. Уровень отступа может быть любым, но принято 4 пробела
2. Для отступа можно использовать, как табуляции(tab), так и пробелы
3. Python запрещает смешивать знаки истинной табуляции и пробелы, но большинство текстовых редактором и IDE автоматически переводит знаки табуляции в 4 пробела. PyCharm в частности
4. Желательно использовать 4 пробела, нежели табуляцию, если редактор кода не умеет пункта 3

	Тернарный оператор
В python существует единственый тернарный оператор. Он записывается следующим образом:
(если_условие_ложно, если_условие_истинно)[условие]

Также справедлива следующая запись:
значение if условие else значение


Это бывает удобно, например:
Есть переменная для хранения количества значений и мы хотим найти среднее арифметическое чисел, которые считаем. Тогда если будет 0, то нужно будет не найти значение, а вывести, что таких чисел нет:
summa = 0
amount - 0
код
код
код
print((summa / amount, "Не было таких чисел")[amount == 0])

Важно стараться рассмотреть все случаи. Например следующий код может зафакапиться:
x_cord = int(input())
y_cord = int(input())
quater = 0
if x_cord > 0 and y_cord > 0:
	quater = 'I'
elif x_cord < 0 and y_cord > 0:
	quater = 'II'
elif x_cord < 0 and y_cord < 0:
	quater = 'III'
elif x_cord > 0 and y_cord < 0:
	quater = 'IV'
else:
	print('НЕВОЗМОЖНО')
if quater != 0:
	print(f'Координатная четверть: {quater}')

Если хотя бы одно число равно нулю, то точка лежит на оси => не находиться в конкретной четверти
Смотри рисунок 5


		6. Циклы
	Цикл while
Цикл while  --  цикл пока

1. Он выполняет инструкции, пока условие верно
2. В процессе выполнения инструкций он НЕ смотрит на условие
3. Если не изменять инструкциями внутри цикла условие, то мы зациклимся навечно

Немножко терминов:
Смотри рисунок 6
Итерация  --  фактическое единичное выполнение тела цикла

Различие между телом цикла и итерацией:
Итерация  --  именно выполнение кода, а тело цикла  --  сам код


Они справедливы для любого цикла

	Комментарии
Чтобы оставить комментарий, нужно поставить # (знак решётки). Всё, что идёт после него в данной строке не обрабатывается интерпретатором

PEP8  --  отступ от кода 2 пробела, отступ после решётки 1 пробел

	Перенос строки
Если строка слишком длинная, то мы можем поставить \ (знак обратного слеша) и он продолжит читать следующую строку, как продолжение этой

Если мы на одной строке окрываем скобки и не закрываем их, то интерпретатор будет читать следующие строки, как продолжение этой, пока не найдёт закрывающей скобки

Если мы хотим уместить несколько строк в одной, то можно поставить ; . После этого символа интерпретатор начинает читать всё как новую строку, если не было других агрументов для продолжения (например незакрытые скобки или ковычки)

PEP8  --  максимальная длина одной строки 79 символов
PEP8  --  если мы открыли скобки и разбили их содержимое на смысловые единицы, то их нужно начинать с одним отступом
print(длинная_очень-очень_длинная_до_невозможности_длинная_строка1,
      длинная_очень-очень_длинная_до_невозможности_длинная_строка2,
      длинная_очень-очень_длинная_до_невозможности_длинная_строка3
      длинная_очень-очень_длинная_до_невозможности_длинная_строка4)
PEP8  --  не принято ставить ; , лучше обойтись следующей строкой
	
	Условие призрак
Если мы используем цикл while, без специальных инструкций, то после него обязательно условие, заложенное для продолжение неверно. Оно и называется условием призраком

То есть если у нас есть:
while a >= 0:
	код
То к концу цикла a точно меньше 0 (a < 0)

Если тело цикла очень большое и сложно за раз охватить его полностью (что плохо и грамотный разработчик так не делает(запиши это и выдели)), то после цикла можно оставить комментарий про условие призрак


Если мы используем специальные инструкции выхода в цикле, то мы разрушаем призрака, т.к. появляется несколько вариантом, почему мог быть закончен цикл

	Цикл for
Цикл for  --  цикл для

1. Он выполняет инструкции, подставляя значение каждого элемента в объекте
2. Цикл for очень трудно зациклить
3. Можно делать цикл не для одной переменной, а для нескольких. Это возможно, только когда каждый объект можно распаковать
4. В цикл for можно запихнуть любой итерируемый объект, то есть объект, к которому можно применить функцию next()


Пример 1
for i in 1, 2, 3:
	инструкции

	Функция range
В python, чтобы не извращаться, как в примере 1 есть генератор арифметических прогрессий. Это функция range. Она вычисляет следующий элемент на основании предыдущего

Общая форма range:
range([start], stop[, step])  --  по умолчанию start = 0, step = 1

Основные моменты:
1. step можно задать и отрицательным, то есть пойти в обратную сторону
2. range работает по следующему принципу:
	1) Вернуть start
	2) Добавить к start значение step
	3) Если start < stop повторить, иначе закончить

То есть к концу нашего курса ты сможешь написать цикл for собственноручно и функцию range собственноручно


Циклы могут быть вложенными. Тогда их тело отделяется новым уровнем отступа

	Специальные инструкции для циклов
break, continue

Обычно их не используют без условий, потому что они меняют ход выполнения инструкций цикла и всё, что шло после них не выполняется

Поэтому в схемах я буду сразу рисовать с условиями

1. break
Досрочно заканчивает цикл и прекращает выполнение инструкций
Смотри рисунок 7

2. continue
Досрочно перейти к следующей итерации
Смотри рисунок 8

Основные моменты:
1. Весь код после этих операторов НЕ выполняется
2. Эти операторы обычно находтся в побочной ветке программы
3. Они применяются к ближайшему циклу, в случае вложенности

	Способы срочно покинуть цикл
Тебе нужно знать 3 таких способа:
1. break
Его ты уже знаешь

2. Вызвать ошибку/исключение(Exception)
Это можно сделать следующим образом:
raise название_ошибки

Это чуть более срочный способ покинуть цикл. После него, если ошибку не обработать, о чём мы поговорим позже, интерпретатор вывалит нам в консоль traceback, о чём мы тоже поговорим позже, и закончит выполнение программы

3. Использовать sys.exit()
Это классовая функция модуля sys. Чтобы её использовать необходимо подключить пространство имён sys:
import sys
После чего мы можем использовать функцию sys.exit()

Она посылает сигнал ОС снять все ресурсы на вчислительные процессы

Как ляпнул Тимофей Фёдорович Хирьянов, цитата: "Он говорит операционной системе: 'Операционная система, кильни меня пожалуйста'"

По срочности от самого несрочного к самому срочному:
1. break
2. Exception
3. sys.exit()

	Else в циклах
Обычно в ЯП-ах так не делают, но в python сделали:
Если цикл закончился по нормальной причине, а не из-за выше упомянтых причин, то выполнится блок else

Его структура выглядит так:
Цикл
else:
	код
Где цикл, термин введённый ранее

		7. Более подробно про некоторые полезные функции 1

print(value, ..., sep=' ', end='\n', file=sys.stdout)
принимает значение или значения и выводит их в file или поток. По умолчанию выводит в консоль
sep - разделитель, ставящийся между всеми значениями
end - то, что ставиться после всех значений, по умолчанию "\n"

Основные моменты:
1. Если мы не передадим print никаких параметров, то выведется просто end
2. Выходная строка формируется по следующему принципу:
	_repr_(value1) + sep + str(value2) + sep + ... + str(valuen) + end


Мы не будем подробно рассматривать ключевой параметр file, т.к. это выходит за рамки нашего курса

input([string])  --  принамет строку с консоли. Если string указан, то сначало выводит string, а затем считывает данные с консоли

id()  --  возвращает идентификатор, с которым связано имя или переданный объект
type(object) - возвращает тип объекта

ord(value) value - строка из одного символа. Возвращает численное значение символа
chr(i)  --  преобразует число в строку состаящую из одного символа, соответсвующего данному индексу


len(object) возвращает параметр длина, если таковой указан в объекте. Пара примеров:
1. Не применимо к Numeric Type
2. Не применимо к None Type
3. Для класса str  --  возвращает длину строки
4. Для объектов-контейнеров  --  возвращает количество элементов внутри
5. Для последовательности возвращает её длину


range([start ,] stop[, step])  --  генератор арифметических прогрессий. Возвращает прогрессию, сгенерированную, начиная с start, с шагом step, пока член прогрессии < stop
По умолчанию start = 0, step = 1
range - итерируемый объект

	Функции для отладки
help(имя_функции/класса)  --  выводит подсказку об этой функции, этом классе
dir(имя_класса)  --  выводит абсолютно все функции, лежащие внутри этого класса

breakpoint  --  позволяет приоставновить выполнение программы и перейти в режим отладки


	Математические функции
abs(x)  --  возвращает модуль числа
round(x)  --  округляет число по правилам округления
divmod(x, y)  --  возвращает одновременно остаток от деления и целую часть от деления
pow(base, exp[, mod])  --  возводит base в степень exp, если mod не указан и находит остаток от деления степени на mod, если mod указан. Эффекстивней, чем pow(base, exp) % mod


	Логарифмы
Найдёшь сама, это не программирование. Для полного понимая лучше удели час - полтора видео с канала Бориса Трушина и всё поймёшь. Если что-то будет непонятно  --  обращайся
1. https://www.youtube.com/watch?v=kDyRtDdxyDE   28 минут
2. https://www.youtube.com/watch?v=wc7-rm65ISw   21 минута
3. https://www.youtube.com/watch?v=NyJGkH2b54M   12 минут
4. https://www.youtube.com/watch?v=_skyZu5ARAs   16 минут

Всего 77 минут. 1 час, 17 минут

	Множества
Ты вроде всё записала


		8. Архитектура компьютера
	Десятичные числа
с.с.  --  система счисления

+  --  сложить
*  --  умножить
^  --  возвести в степень

Десятичные числа закодированы в двоичной с.с.

Экспонента  --  число, на степень которого умножается каждый 0 или 1 в двоичной записи числа

Эпсилион  --  относительная погрешность при определённой экспоненте; относительная погрешность в окрестности числа


Например 0110,1101  можно представить как 0 * 2^3 + 1 * 2^2 + 1 * 2^1 + 0 * 2^0 + 1 * 2^-1 + 1 * 2^-2 + 0 * 2^-3 + 1 * 2^-4

Число имеет фиксированную длину, поэтому для презентации более больших и более маленьких чисел мы начинаем с большей или меньшей экспонент

Некоторые особенности
1. Фиксированная запятая(никакого смещения):
0000,0000 (здесь экспонента = 3)

2. Плавающая запятая(экспонента представляет смещение относительно старших бит):
0000,0000  --  экспонента = 3
000,00000  --  экспонента = 2
00,000000  --  экспонента = 1
0,0000000  --  экспонента = 0

3. Нормализованный вид(неянвая единица вначале. Обычно её не видно):
1 000,0000  --  экспонента = 3
1 00,00000  --  экспонента = 2
1 0,000000  --  экспонента = 1
1 ,0000000  --  экспонента = 0

Общий вид числа float80 в python:
sign_bit * 1 + exp_bit * 15 + 1 * normalized_bit + mantissa_bit * 53
Смотри рисунок 9

Из экспоненты вычитается 011111111111111, чтобы мы могли получать дробные числа. То есть чтобы экспонента была 0, биты под экспоненту должны выглядить так: 011111111111111

Особенности:
1. Так как при больших значениях числа, требуется большая экспонента, то при увеличении кодируемого числа точность понижается и в какой-то момент может превысить 1 и даже стать 128. За этим нужно следить

	Как составляются пути
В ОС Windows в пути к каждому файлы или папке:
Название_диска:\Папка1\Папка2\...\Конечная_папка

Например:
C:\Users\User\Desktop

Путь к папке можно оканчивать \, это не повлияет на конечную папку

Если нам нужен файл, то в конце пути мы просто дописываем его полное название:
название.расширение

При этом в названии могут содержаться точки

Например 
C:\Users\User\Desktop\1.1.py

Расширения

У файлов, которые являются исполняемыми расширение .exe

Файлы для хранения и передачи картинок:
.jpeg, .jpg  --  картинка, поддерживающая большое разнообразие цветов
.png  --  картинка, поддерживающая прозрачные цвета
.gif  --  гифка

Драйвера:
.dll  --  тебе нужно знать, что это драйвера, не более

Драйвер  --  ПО для работы с подключаемыми устройствами


Как составляются URL адреса сайтов
URL – это адрес документа или файла. Аббревиатура URL составлена из Uniform Resource Locator, что в переводе означает "Единый указатель ресурсов"

Адрес состоит из:
1. протокола
2. доменного имени
3. url пути
Необязательно:
4. якоря
5. параметров

Протокол отделяется с помощью ://
Доменное имя и url путь отделяются /
Доменное имя внутри разделяется .
Url путь внутри разделяется /
Якорь отделяется #
Параметры передаются через ?
Параметры внутри разделяются &
Параметры начинаются с имени, затем равно и значение

В адресе не может быть пробелов. Все специальные символы кодируются определённым образом

Смотри рисунок 11


Мы рассмотрим два протокола:
HTTP — это протокол передачи гипертекста. Он применяется при обмене данными с серверов – подключенному к Интернету компьютеру пользователя по его запросу
FTP — протокол, назначение которого — передача документов с сервера на персональное устройство пользователя. FTP позволяет обмениваться документами любым компьютерам сети

http делится на http и https
Смотри рисунок 12

Доменное имя
Мы рассмотрим имена только первого и второго уровней, но не сомневайся есть и корневое имя и домены 3, 4, и 5 уровней

Справо налево назначаются уровни домена начиная с первого. Самый правый называется доменом верхнего уровня или верховным доменом

Например:
Смотри рисунок 13


	Литералы
Литерал  --  это константы, зарезервированные символы определённых типов данных

	Целочисленные литералы
1. Число
Например:
1
2
7
5

2. Двоичные числа  //Начинаются с 0b
Например:
0b101
0b110
0b1001

3. Восьмиричные числа  //Начиснаются с 0o
Например:
0o73
0o123
0o77

4. Шестнадцатиричные числа  //Начинаются с 0x
Например:
0xaf3
0x0b

	Дробные литералы
1. Десятичные числа
Например:
32.094
1.909
.94
0.0

2. Десятичные нормализованные числа
Например:
5.6453e-43
1.5e2

	Комплексные литералы
1. Комплексные числа
Например:
5+3.14j

	Булевы литералы
1. Булевы числа
Например:
True
False

Это все булевы литералы

	Специальные литералы
1. None
Например:
None


Остальные литералы мы рассмотрим в этом блоке



		9. Структуры данных
Структура данных  --  это контейнер, который хранит данные в определенном макете. Этот "макет" позволяет структуре данных быть эффективной в некоторых операциях и неэффективной в других

Структура данных  --  программная единица, позволяющая хранить и обрабатывать множество однотипных и/или логически связанных данных в вычислительной технике. Для добавления, поиска, изменения и удаления данных структура данных предоставляет некоторый набор функций, составляющих её интерфейс

Коллекция  --  программный объект, содержащий в себе, тем или иным образом, набор значений одного или различных типов, и позволяющий обращаться к этим значениям


В Python существуют четыре встроенных структуры данных: список, кортеж, словарь и множество

Схема коллекций:
Смотри рисунок 14.1
Смотри рисунок 14.2

	Общие методы работы с коллекциями
Индексированность  --  каждый элемент коллекции имеет свой порядковый номер — индекс. Это позволяет обращаться к элементу по его порядковому индексу, проводить слайсинг (нарезку) — брать часть коллекции выбирая исходя из их индекса

Уникальность  --  каждый элемент коллекции может встречаться в ней только один раз. Это порождает требование неизменности используемых типов данных для каждого элемента, например, таким элементом не может быть список

Изменяемость коллекции  --  позволяет добавлять в коллекцию новых членов или удалять их после создания коллекции

# Зададим исходно список и словарь:
my_list = ['a', 'b', 'c', 'd', 'e', 'f']
my_dict = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}


1. Печать элементов коллекции с помощью функции print()

print(my_list)   # ['a', 'b', 'c', 'd', 'e', 'f']
print(my_dict)   # {'a': 1, 'c': 3, 'e': 5, 'f': 6, 'b': 2, 'd': 4}

Примечание:
Порядок элементов в неиндексированных коллекциях не сохраняется


2. Подсчёт количества членов коллекции с помощью функции len()

print(len(my_list)) # 6
print(len(my_dict)) # 6 - для словаря пара ключ-значение считаются одним элементом
print(len('ab c')) # 4 - для строки элементом является 1 символ


3. Проверка принадлежности элемента данной коллекции c помощью оператора in

x in s — вернет True, если элемент входит в коллекцию s и False — если не входит
Есть и вариант проверки не принадлежности: x not in s, где есть по сути, просто добавляется отрицание перед булевым значением предыдущего выражения

my_list = ['a', 'b', 'c', 'd', 'e', 'f']
print('a' in my_list)           # True
print('q' in my_list)           # False
print('a' not in my_list)       # False
print('q' not in my_list)       # True

Примечание:
Для словаря возможны варианты, понятные из кода ниже:

my_dict = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}
print('a' in my_dict)               # True - без указания метода поиск по ключам
print('a' in my_dict.keys())        # True - аналогично примеру выше
print('a' in my_dict.values())      # False - так как 'а' — ключ, не значение
print(1 in my_dict.values())        # True

Можно ли проверять пары? Можно!

print(('a',1) in my_dict.items())   # True
print(('a',2) in my_dict.items())   # False

Для строки можно искать не только один символ, но и подстроку:

print('ab' in 'abc')    # True


4. Обход всех элементов коллекции в цикле for in

В данном случае, в цикле будут последовательно перебираться элементы коллекции, пока не будут перебраны все из них

for elm in my_list:
    print(elm)

Примечание:
Порядок обработки элементов для не индексированных коллекций будет не тот, как при их создании
У прохода в цикле по словарю есть свои особенности:

for elm in my_dict:
 	# При таком обходе словаря, перебираются только ключи
	# равносильно for elm in my_dict.keys()
 	print(elm)

for elm in my_dict.values():
 	# При желании можно пройти только по значениям
 	print(elm)

Но чаще всего нужны пары ключ(key) — значение (value).

for key, value in my_dict.items():
	# Проход по .items() возвращает кортеж (ключ, значение), 
	# который присваивается кортежу переменных key, value
	print(key, value)

Примечание:
Возможная ошибка: Не меняй количество элементов коллекции в теле цикла во время итерации по этой же коллекции! — Это порождает не всегда очевидные на первый взгляд ошибки

Чтобы этого избежать подобных побочных эффектов, можно, например, итерировать копию коллекции:

for elm in list(my_list):
    	# Теперь можешь удалять и добавлять элементы в исходный список my_list,
    	# так как итерация идет по его копии


5. Функции min(), max(), sum()

Функции min(), max() — поиск минимального и максимального элемента соответственно — работают не только для числовых, но и для строковых значений
sum() — суммирование всех элементов, если они все числовые

print(min(my_list))               # a
print(sum(my_dict.values()))      # 21

6. Распаковка набора элементов
Переменная1, переменная2, переменная3, ..., переменнаяN = (элемент1, элемент2, ..., элементN)

Например:
a, b, c = 1, 2, 3
Это то же, что и
a = 1
b = 2
c = 3



	Общие методы для части коллекций

Ряд методов у коллекционных типов используется в более чем одной коллекции для решения задач одного типа
Смотри рисунок 15

.count() — метод подсчета определенных элементов для неуникальных коллекций (строка, список, кортеж), возвращает сколько раз элемент встречается в коллекции

my_list = [1, 2, 2, 2, 2, 3]
print(my_list.count(2))     # 4 экземпляра элемента равного 2
print(my_list.count(5))     # 0 - то есть такого элемента в коллекции нет


.index() — возвращает минимальный индекс переданного элемента для индексированных коллекций (строка, список, кортеж)

my_list = [1, 2, 2, 2, 2, 3]
print(my_list.index(2))  # первый элемент равный 2 находится по индексу 1 (индексация с нуля!)
print(my_list.index(5))  # ValueError: 5 is not in list - отсутствующий элемент выдаст ошибку!


.copy() — метод возвращает неглубокую (не рекурсивную) копию коллекции (список, словарь, оба типа множества)

my_set = {1, 2, 3}
my_set_2 = my_set.copy()
print(my_set_2 == my_set)  # True - коллекции равны - содержат одинаковые значения
print(my_set_2 is my_set)  # False - коллекции не идентичны - это разные объекты с разными id


.clear() — метод изменяемых коллекций (список, словарь, множество), удаляющий из коллекции все элементы и превращающий её в пустую коллекцию

my_set = {1, 2, 3}
print(my_set)  # {1, 2, 3}
my_set.clear()
print(my_set)  # set()

К индексированным коллекциям можно применять следующие операции

Особые методы сравнения множеств (set, frozenset)

set_a.isdisjoint(set_b) — истина, если set_a и set_b не имеют общих элементов.
set_b.issubset(set_a) — если все элементы множества set_b принадлежат множеству set_a, то множество set_b целиком входит в множество set_a и является его подмножеством (set_b — подмножество)
set_a.issuperset(set_b) — соответственно, если условие выше справедливо, то set_a — надмножество

set_a = {1, 2, 3}              
set_b = {2, 1}                  # порядок элементов не важен!
set_c = {4}
set_d = {1, 2, 3}

print(set_a.isdisjoint(set_c))  # True - нет общих элементов
print(set_b.issubset(set_a))    # True  - set_b целиком входит в set_a, значит set_b - подмножество
print(set_a.issuperset(set_b))  # True - set_b целиком входит в set_a, значит set_a - надмножество

При равенстве множеств они одновременно и подмножество и надмножество друг для друга
print(set_a.issuperset(set_d))  # True
print(set_a.issubset(set_d))    # True


	Конвертация одного типа коллекции в другой

В зависимости от стоящих задач, один тип коллекции можно конвертировать в другой тип коллекции. Для этого, как правило достаточно передать одну коллекцию в функцию создания другой

my_tuple = ('a', 'b', 'a')
my_list = list(my_tuple)
my_set = set(my_tuple)		        # теряем индексы и дубликаты элементов!
my_frozenset = frozenset(my_tuple)      # теряем индексы и дубликаты элементов!
print(my_list, my_set, my_frozenset)    # ['a', 'b', 'a'] {'a', 'b'} frozenset({'a', 'b'})

Обрати внимание, что при преобразовании одной коллекции в другую возможна потеря данных:

1. При преобразовании в множество теряются дублирующие элементы, так как множество содержит только уникальные элементы! Собственно, проверка на уникальность, обычно и является причиной использовать множество в задачах, где у нас есть в этом потребность
2. При конвертации индексированной коллекции в неиндексированную теряется информация о порядке элементов, а в некоторых случаев она может быть критически важной!
3. После конвертации в не изменяемый тип, мы больше не сможем менять элементы коллекции — удалять, изменять, добавлять новые. Это может привести к ошибкам в наших функциях обработки данных, если они были написаны для работы с изменяемыми коллекциями


Дополнительные детали:

Способом выше не получится создать словарь, так как он состоит из пар ключ: значение

Это ограничение можно обойти, создав словарь комбинируя ключи со значениями с использованием zip():

my_keys = ('a', 'b', 'c')
my_values = [1, 2]      # Если количество элементов разное - 
		        		# будет отработано пока хватает на пары - лишние отброшены

my_dict = dict(zip(my_keys, my_values))
print(my_dict)          # {'a': 1, 'b': 2}


Создаем строку из другой коллекции:

my_tuple = ('a', 'b', 'c')
my_str = ''.join(my_tuple)
print(my_str)           # abc

Возможная ошибка: Если твоя коллекция содержит изменяемые элементы (например список списков), то ее нельзя конвертировать в не изменяемую коллекцию, так как ее элементы могут быть только не изменяемыми!

my_list = [1, [2, 3], 4]
my_set = set(my_list)   # TypeError: unhashable type: 'list'

	Индексирование

1 Индексированные коллекции

Рассмотрим индексированные коллекции (их еще называют последовательности — sequences) — список (list), кортеж (tuple), строку (string).

Под индексированностью имеется ввиду, что элементы коллекции располагаются в определённом порядке, каждый элемент имеет свой индекс от 0 (то есть первый по счёту элемент имеет индекс не 1, а 0) до индекса на единицу меньшего длины коллекции (т.е. len(mycollection)-1).

2 Получение значения по индексу

Для всех индексированных коллекций можно получить значение элемента по его индексу в квадратных скобках. Причем, можно задавать отрицательный индекс, это значит, что будем находить элемент с конца считая обратном порядке.

При задании отрицательного индекса, последний элемент имеет индекс -1, предпоследний -2 и так далее до первого элемента индекс которого равен значению длины коллекции с отрицательным знаком, то есть (-len(mycollection).
элементы	a	b	c	d	e
индексы	0 (-5)	1 (-4)	2 (-3)	3 (-2)	4 (-1)
	my_str = "abcde"
	print(my_str[0]) 		# a - первый элемент
	print(my_str[-1])		# e - последний элемент 
	print(my_str[len(my_str)-1]) 	# e - так тоже можно взять последний элемент
	print(my_str[-2]) 		# d - предпоследний элемент

Наши коллекции могут иметь несколько уровней вложенности, как список списков в примере ниже. Для перехода на уровень глубже ставится вторая пара квадратных скобок и так далее.

my_2lvl_list = [[1, 2, 3], ['a', 'b', 'c']]
print(my_2lvl_list[0])      # [1, 2, 3] - первый элемент — первый вложенный список
print(my_2lvl_list[0][0])   # 1 — первый элемент первого вложенного списка
print(my_2lvl_list[1][-1])  # с — последний элемент второго вложенного списка

3 Изменение элемента списка по индексу

Поскольку кортежи и строки у нас неизменяемые коллекции, то по индексу мы можем только брать элементы, но не менять их:

my_tuple = (1, 2, 3, 4, 5)
print(my_tuple[0])	  # 1
my_tuple[0] = 100         # TypeError: 'tuple' object does not support item assignment

А вот для списка, если взятие элемента по индексу располагается в левой части выражения, а далее идёт оператор присваивания =, то мы задаём новое значение элементу с этим индексом.

my_list = [1, 2, 3, [4, 5]]
my_list[0] = 10
my_list[-1][0] = 40
print(my_list)      	# [10, 2, 3, [40, 5]]

Примечание: Для такого присвоения, элемент уже должен существовать в списке, нельзя таким образом добавить элемент на несуществующий индекс.

my_list = [1, 2, 3, 4, 5]
my_list[5] = 6      # IndexError: list assignment index out of range


	Срезы

1 Синтаксис среза

Очень часто, надо получить не один какой-то элемент, а некоторый их набор ограниченный определенными простыми правилами — например первые 5 или последние три, или каждый второй элемент — в таких задачах, вместо перебора в цикле намного удобнее использовать так называемый срез (slice, slicing).

Следует помнить, что взяв элемент по индексу или срезом (slice) мы не как не меняем исходную коллекцию, мы просто скопировали ее часть для дальнейшего использования (например добавления в другую коллекцию, вывода на печать, каких-то вычислений). Поскольку сама коллекция не меняется — это применимо как к изменяемым (список) так и к неизменяемым (строка, кортеж) последовательностям.

Синтаксис среза похож на таковой для индексации, но в квадратных скобках вместо одного значения указывается 2-3 через двоеточие:

my_collection[start:stop:step]  # старт, стоп и шаг

Особенности среза:

Отрицательные значения старта и стопа означают, что считать надо не с начала, а с конца коллекции.
Отрицательное значение шага — перебор ведём в обратном порядке справа налево.
Если не указан старт [:stop:step]— начинаем с самого края коллекции, то есть с первого элемента (включая его), если шаг положительный или с последнего (включая его), если шаг отрицательный (и соответственно перебор идет от конца к началу).
Если не указан стоп [start:: step] — идем до самого края коллекции, то есть до последнего элемента (включая его), если шаг положительный или до первого элемента (включая его), если шаг отрицательный (и соответственно перебор идет от конца к началу).
step = 1, то есть последовательный перебор слева направо указывать не обязательно — это значение шага по умолчанию. В таком случае достаточно указать [start:stop]
Можно сделать даже так [:] — это значит взять коллекцию целиком
ВАЖНО: При срезе, первый индекс входит в выборку, а второй нет!
То есть от старта включительно, до стопа, где стоп не включается в результат. Математически это можно было бы записать как [start, stop) или пояснить вот таким правилом:
[ <первый включаемый> : <первый НЕ включаемый> : <шаг> ]

Поэтому, например, mylist[::-1] не идентично mylist[:0:-1], так как в первом случае мы включим все элементы, а во втором дойдем до 0 индекса, но не включим его!

Примеры срезов в виде таблицы:

Смотри рисунок 16

Код примеров из таблицы
2. Именованные срезы

Чтобы избавится от «магических констант», особенно в случае, когда один и тот же срез надо применять многократно, можно задать константы с именованными срезами с пользованием специальной функции slice()()

Примечание: Nonе соответствует опущенному значению по-умолчанию. То есть [:2] становится slice(None, 2), а [1::2] становится slice(1, None, 2).

person = ('Alex', 'Smith', "May", 10, 1980)
NAME, BIRTHDAY = slice(None, 2), slice(2, None)       
	# задаем константам именованные срезы
        # данные константы в квадратных скобках заменятся соответствующими срезами
print(person[NAME])      # ('Alex', 'Smith')
print(person[BIRTHDAY])  # ('May', 10, 1980)

my_list = [1, 2, 3, 4, 5, 6, 7]
EVEN = slice(1, None, 2)
print(my_list[EVEN])     # [2, 4, 6]

3. Изменение списка срезом

Важный момент, на котором не всегда заостряется внимание — с помощью среза можно не только получать копию коллекции, но в случае списка можно также менять значения элементов, удалять и добавлять новые.

Проиллюстрируем это на примерах ниже:

Даже если хотим добавить один элемент, необходимо передавать итерируемый объект, иначе будет ошибка TypeError: can only assign an iterable

my_list = [1, 2, 3, 4, 5]
# my_list[1:2] = 20     # TypeError: can only assign an iterable
my_list[1:2] = [20]     # Вот теперь все работает
print(my_list)          # [1, 20, 3, 4, 5]

Для вставки одиночных элементов можно использовать срез, код примеров есть ниже, но делать так не рекомендую, так как такой синтаксис хуже читать. Лучше использовать методы списка .append() и .insert():

Срез аналоги .append() и insert()
Можно менять части последовательности — это применение выглядит наиболее интересным, так как решает задачу просто и наглядно.

my_list = [1, 2, 3, 4, 5]
my_list[1:3] = [20, 30]
print(my_list)          # [1, 20, 30, 4, 5]
my_list[1:3] = [0]      # нет проблем заменить два элемента на один
print(my_list)          # [1, 0, 4, 5]
my_list[2:] = [40, 50, 60]   # или два элемента на три
print(my_list)               # [1, 0, 40, 50, 60]

Можно просто удалить часть последовательности

my_list = [1, 2, 3, 4, 5]
my_list[:2] = []    # или del my_list[:2]
print(my_list)      # [3, 4, 5]

4. Выход за границы индекса

Обращение по индексу по сути является частным случаем среза, когда мы обращаемся только к одному элементу, а не диапазону. Но есть очень важное отличие в обработке ситуации с отсутствующим элементом с искомым индексом.

Обращение к несуществующему индексу коллекции вызывает ошибку:

my_list = [1, 2, 3, 4, 5]
print(my_list[-10])       # IndexError: list index out of range
print(my_list[10])        # IndexError: list index out of range

А в случае выхода границ среза за границы коллекции никакой ошибки не происходит:

my_list = [1, 2, 3, 4, 5]
print(my_list[0:10])      # [1, 2, 3, 4, 5] — отработали в пределах коллекции
print(my_list[10:100])	  # [] - таких элементов нет — вернули пустую коллекцию
print(my_list[10:11])     # [] - проверяем 1 отсутствующий элемент - пустая коллекция, без ошибки


Примечание: Для тех случаев, когда функционала срезов недостаточно и требуются более сложные выборки, можно воспользоваться синтаксисом выражений-генераторов, рассмотрению которых посвещена 4 статья цикла.

	Сортировка элементов коллекции

Сортировка элементов коллекции важная и востребованная функция, постоянно встречающаяся в обычных задачах. Тут есть несколько особенностей, на которых не всегда заостряется внимание, но которые очень важны.

1 Функция sorted()

Мы может использовать функцию sorted() для вывода списка сортированных элементов любой коллекции для последующее обработки или вывода.

функция не меняет исходную коллекцию, а возвращает новый список из ее элементов;
не зависимо от типа исходной коллекции, вернётся список (list) ее элементов;
поскольку она не меняет исходную коллекцию, ее можно применять к неизменяемым коллекциям;
Поскольку при сортировке возвращаемых элементов нам не важно, был ли у элемента некий индекс в исходной коллекции, можно применять к неиндексированным коллекциям;
Имеет дополнительные не обязательные аргументы:
reverse=True — сортировка в обратном порядке
key=funcname (начиная с Python 2.4) — сортировка с помощью специальной функции funcname, она может быть как стандартной функцией Python, так и специально написанной вами для данной задачи функцией и лямбдой.

my_list = [2, 5, 1, 7, 3]
my_list_sorted = sorted(my_list)
print(my_list_sorted)       # [1, 2, 3, 5, 7]

my_set = {2, 5, 1, 7, 3}
my_set_sorted = sorted(my_set, reverse=True)
print(my_set_sorted)        # [7, 5, 3, 2, 1]

Пример сортировки списка строк по длине len() каждого элемента:

my_files = ['somecat.jpg', 'pc.png', 'apple.bmp', 'mydog.gif']
my_files_sorted = sorted(my_files, key=len)
print(my_files_sorted)      # ['pc.png', 'apple.bmp', 'mydog.gif', 'somecat.jpg']

2 Функция reversed()

Функция reversed() применяется для последовательностей и работает по другому:

возвращает генератор списка, а не сам список;
если нужно получить не генератор, а готовый список, результат можно обернуть в list() или же вместо reversed() воспользоваться срезом [: :-1];
она не сортирует элементы, а возвращает их в обратном порядке, то есть читает с конца списка;
из предыдущего пункта понятно, что если у нас коллекция неиндексированная — мы не можем вывести её элементы в обратном порядке и эта функция к таким коллекциям не применима — получим «TypeError: argument to reversed() must be a sequence»;
не позволяет использовать дополнительные аргументы — будет ошибка «TypeError: reversed() does not take keyword arguments».

my_list = [2, 5, 1, 7, 3]
my_list_sorted = reversed(my_list)
print(my_list_sorted)           # <listreverseiterator object at 0x7f8982121450>
print(list(my_list_sorted))     # [3, 7, 1, 5, 2]
print(my_list[::-1])            # [3, 7, 1, 5, 2] - тот же результат с помощью среза

3 Методы списка .sort() и .reverse()

У списка (и только у него) есть особые методы .sort() и .reverse() которые делают тоже самое, что соответствующие функции sorted() и reversed(), но при этом:

Меняют сам исходный список, а не генерируют новый;
Возвращают None, а не новый список;
поддерживают те же дополнительные аргументы;
в них не надо передавать сам список первым параметром, более того, если это сделать — будет ошибка — не верное количество аргументов.

my_list = [2, 5, 1, 7, 3]
my_list.sort()
print(my_list)          # [1, 2, 3, 5, 7]

Обратите внимание: Частая ошибка начинающих, которая не является ошибкой для интерпретатора, но приводит не к тому результату, который хотят получить.

my_list = [2, 5, 1, 7, 3]
my_list = my_list.sort()
print(my_list)          # None

4 Особенности сортировки словаря

В сортировке словаря есть свои особенности, вызванные тем, что элемент словаря — это пара ключ: значение.

Так же, не забываем, что говоря о сортировке словаря, мы имеем ввиду сортировку полученных из словаря данных для вывода или сохранения в индексированную коллекцию. Сохранить данные сортированными в самом стандартном словаре не получится, они в нем, как и других неиндексированных коллекциях находятся в произвольном порядке.

sorted(my_dict) — когда мы передаем в функцию сортировки словарь без вызова его дополнительных методов — идёт перебор только ключей, сортированный список ключей нам и возвращается;
sorted(my_dict.keys()) — тот же результат, что в предыдущем примере, но прописанный более явно;
sorted(my_dict.items()) — возвращается сортированный список кортежей (ключ, значение), сортированных по ключу;
sorted(my_dict.values()) — возвращается сортированный список значений

my_dict = {'a': 1, 'c': 3, 'e': 5, 'f': 6, 'b': 2, 'd': 4}
mysorted = sorted(my_dict)
print(mysorted)           # ['a', 'b', 'c', 'd', 'e', 'f']
mysorted = sorted(my_dict.items())
print(mysorted)           # [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5), ('f', 6)]
mysorted = sorted(my_dict.values())
print(mysorted)           # [1, 2, 3, 4, 5, 6]

Отдельные сложности может вызвать сортировка словаря не по ключам, а по значениям, если нам не просто нужен список значений, и именно выводить пары в порядке сортировки по значению.

Для решения этой задачи можно в качестве специальной функции сортировки передавать lambda-функцию lambda x: x[1] которая из получаемых на каждом этапе кортежей (ключ, значение) будет брать для сортировки второй элемент кортежа.

population = {"Shanghai": 24256800, "Karachi": 23500000, "Beijing": 21516000, "Delhi": 16787941}
# отсортируем по возрастанию населения:
population_sorted = sorted(population.items(), key=lambda x: x[1])
print(population_sorted)
# [('Delhi', 16787941), ('Beijing', 21516000), ('Karachi', 23500000), ('Shanghai', 24256800)]


5 Дополнительная информация по использованию параметра key при сортировке

Допустим, у нас есть список кортежей названий деталей и их стоимостей.
Нам нужно отсортировать его сначала по названию деталей, а одинаковые детали по убыванию цены.

shop = [('каретка', 1200), ('шатун', 1000), ('седло', 300),
        ('педаль', 100), ('седло', 1500), ('рама', 12000),
        ('обод', 2000), ('шатун', 200), ('седло', 2700)]

def prepare_item(item):
    return (item[0], -item[1])

shop.sort(key=prepare_item)

Результат сортировки

for det, price in shop:
    print('{:<10} цена: {:>5}р.'.format(det, price))

# каретка    цена:  1200р.
# обод       цена:  2000р.
# педаль     цена:   100р.
# рама       цена: 12000р.
# седло      цена:  2700р.
# седло      цена:  1500р.
# седло      цена:   300р.
# шатун      цена:  1000р.
# шатун      цена:   200р.

Перед тем, как сравнивать два элемента списка к ним применялась функция prepare_item, которая меняла знак у стоимости (функция применяется ровно по одному разу к каждому элементу. В результате при одинаковом первом значении сортировка по второму происходила в обратном порядке.

Чтобы не плодить утилитарные функции, вместо использования сторонней функции, того же эффекта можно добиться с использованием лямбда-функции.

# Данные скопировать из примера выше
shop.sort(key=lambda x: (x[0], -x[1]))

6 Устойчивость сортировки

Допустим данные нужно отсортировать сначала по столбцу А по возрастанию, затем по столбцу B по убыванию, и наконец по столбцу C снова по возрастанию.

Если данные в столбце B числовые, то при помощи подходящей функции в key можно поменять знак у элементов B, что приведёт к необходимому результату.
А если все данные текстовые? Тут есть такая возможность.
Дело в том, что сортировка sort в Python устойчивая (начиная с Python 2.2), то есть она не меняет порядок «одинаковых» элементов.

Поэтому можно просто отсортировать три раза по разным ключам:
data.sort(key=lambda x: x['C'])
data.sort(key=lambda x: x['B'], reverse=True)
data.sort(key=lambda x: x['А'])


Более конкретно про каждый тип

	Кортеж
Кортеж  --  это неизменяемый последовательный набор элементов. Он является неизменяемым, итерируемым объектом

Элементы кортежа могут быть представлены РАЗНЫМИ ТИПАМИ

Кортежи в python представляются классом tuple

Литерал кортежа:
Значения в круглых скобках, разделённые запятыми

Создать кортеж можно следующим образом:
1. Просто подсунув набор элементов
a = 1, 2, 3

2. Прописав кортеж литералом:
a = (1, 2, 3)

3. Сделать на основании другого объекта:
a = tuple(obj=())  --  obj iterable объект

Примечание:
Другим объектом может выступать и сам кортеж. То есть можно сделать кортеж из кортежа

Кортеж можно распаковать

Особенности кортежа:
1. Меньший размер по сравнению со списками
2. Неизменяемость
3. built-in тип
4. Коллекция


Операции над кортежами:
1. Сложение
Сложение двух кортежей возвращает кортеж состоящий из элементов обоих кортежей. При этом сохраняется порядок элементов. Сначала идут те, что были в правом кортеже, затем те, что были в левом
(1, 2) + (2, 3) вернёт нам (1, 2, 2, 3)

2. Оператор членства
7 in (1, 5, 8, 7, 7) вернёт True

3. Операторы сравнения
(1, 2, 3)  ==  (3, 2, 1) вернёт False
(1, 2, 7) > (1, 2, 6) вернёт True
(1, 2) < (1, 2, 3) вернёт True

4. Доступ по индексу
a = (1, 2, 3)
a[1] вернёт 2
(1, 2, 3, 4, 5, 6, 9)[4] вернёт 5

5. Срез
(1, 5, 3, 2, 7)[1:3] вернёт(5, 3) 

5. len
len((1, 3, 5)) вернёт 3

6. Умножение
(1, 2) * 7 вернёт (1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2)


Классовые методы:
1. count(self, value, /)  --  считает сколько value в кортеже
t = (7, 7, 7, 9, 6)
t.count(10) вернёт 0
t.count(7) вернёт 3
(7, 6, 6).count(6) вернёт 6

2. index(self, value, start=0, stop=9223372036854775807, /)  --  возвращает индекс первого встретившегося value начиная со start и заканчивая stop. Если не находит value, вызывает ошибку ValueError
(12, 4, 2, 7, 4, 53).index(7) вернёт 3
a = (5, 7, 3, 1, 7, 88)
a.index(7) вернёт 1
a.index(7, 2) вернёт 5
a.index(900) вызовет ошибку ValueError
a.index(7, 2, 4) вызовет ошибку ValueError
a.index(7, 2, 5) вернёт 4


Можно превести к строке


Как создать кортеж из 1 элемента:
(elem,)

Без запятой python воспринимает это, как выражение, которое нужно вычислить. И соответсвенно вычисляет, раскрывая скобки

	Списки
Список  --  это изменяемый последовательный набор элементов. Он является изменяемым итерируемым объектом

Элементы списка могут быть представлены РАЗНЫМИ ТИПАМИ

Списки в python представляются классом list

Литерал списка:
Значения в квадратных скобках, разделённые запятыми

Создать список можно следующим образом:
1. Прописав список литералом:
a = [1, 2, 3]

2. Сделать на основании другого объекта:
a = list(obj=[])  --  obj iterable объект

Примечание:
Другим объектом может выступать и сам список. То есть можно сделать список из другого списка

Список можно распаковать

Особенности списка:
1. Изменяемость
2. Последовательное хранение элементов
3. Распаковка неопределённого числа элементов делается в список
4. built-in тип
5. Коллекция

Распаковка:
Списки можно распаковать, как и кортежи

Распаковка в список:
*название_переменной = элемент1, элемент2, ..., элементN

Можно распаковать например только первые 3 элемента, а остальные запихнкть в список:
a, b, c, *args = 1, 2, 4, 5, 'sdg', 23

Это аналогично
a = 1
b = 2
c = 4
args = [5, 'sdg', 23]


Классовые методы:
1. append(el)  --  добавляет el в конец списка
a = ['l', 'o']
a.append('l')  # ['l', 'o', 'l']


2. insert(index, el)  --  добавляет el на место index. При этом все остальные элементы сдвигаются вправо
a = [1, 3, 3, 7]
a.insert(2, 74)  # [1, 3, 74, 3, 7]

a = [1, 3, 3, 7]
a.insert(9999999999999, 1)  # [1, 3, 3, 7, 1]


3. index(el)  --  возвращает индекс el. Если не находит, вызывает ошибку ValueError
a = ['a', 'b', 'c']
a.index('b')  # 1
a.index(4)  # ValueError: 4 not in list


4. pop([index])  --  возвращает элемент по индексу, удаляя его из списка. Если индекса не существует, InexError
a = [1, 2, 3, 4, 5]
b = a.pop(3)  # b - 4  a - [1, 2, 3, 5]
c = a.pop()  # c - 5  a - [1, 2, 3]
q = a.pop(-2)  # q - 2  a - [1, 3]
a.pop(999)  # IndexError: pop index out of range
[].pop()  # IndexError: pop from empty list


5. extend(collection)  --  добавляет в конец списка все элементы из collection, где collection - коллекция
a = []
a.extend((1, 2))  # [1, 2]
a.extend([3, 4])  # [1, 2, 3, 4]
a.extend({5, 6, 7})  # [1, 2, 3, 4, 5, 6, 7]

a = []
b = {'a': 10, 'b': 20}
a.extend(b)  # ['a', 'b']
a.extend(b.values())  # ['a', 'b', 10, 20]
a.extend(b.items())  # ['a', 'b', 10, 20, ('a', 10), ('b', 20)]

a = []
a.extend(b.keys())  # ['a', 'b']


6. remove(el)  --  удаляет первый попавшийся элемент из списка. Если нету такого элемента, ValueError
a = [1, 2, 3, 1]
a.remove(1)  # [2, 3, 1]
a.remove(1)  # [2, 3]
a.remove(5)  # ValueError: list.remove(x): x not in list


7. clear()  --  очищает список от всех элементов
a = ['Oh', 'my', 'god', '!!!', 1, 2, 3]
a.clear()  # []


8. copy()  --  возвращает копию списка
a = [1, 2, 3]
b = a
c = a.copy()
a == b  # True
a == c  # True
a is b  # True
a is c  # False


9. count(el)  --  возвращает количество el в списке
a = [1, 2, 2, 3, 3, 3, 4]
a.count(0)  # 0
a.count(1)  # 1
a.count(2)  # 2
a.count(3)  # 3
a.count(4)  # 1
a.count(5)  # 0


10. reverse()  --  элемент в списке задом наперёд
a = [1, 'l', (9,), 144, 'abc']
a.reverse()  # ['abc', 144, (9,), 'l', 1]
[1, 3, 2]  # [2, 3, 1]
a.reverse()  # [1, 'l', (9,), 144, 'abc']


11. sort(*, key=None, reverse=False)  --  сортирует список по возрастанию. key, reverse - ключевые аргументы. reverse - сортировать по убыванию. key - функция, применяемая к каждому элементу списка перед сортировкой, но сортирующая первоначальные элементы
Перечитай про key, пока не поймёшь
a = [3, 2, 5, 1, 2]
a.sort()  # [1, 2, 2, 3, 5]

a = ['b', 'z', 'q', 'f']
a.sort(reverse=True)  # ['z', 'q', 'f', 'b']

a = [1, '2', 6, 9, '5', 2]
a.sort(key=int)  # [1, '2', 2, '5', 6, 9]


	Словарь
Словарь почти= хэш-таблица

Словарь  --  это изменяемый неупорядоченный набор элементов "ключ:значение"
Ключ  --  уникальный, хэшируемый

Словари в python представляются классом dict

Литерал словаря:
{}

Примечание: внутри обязаны быть пары "ключ: значение". Пустые {} обозначают пустой словарь

Как создать словарь:
1. Литералом
a = {2: 3, 5: 6}
b = {}

2. Из другой коллекции, которая состоит из пар элементов: 1 - ключ, 2 - значение
a = dict([(1, 'a'), (2, 'b'), (3, 'c')])  # a = {1: 'a', 2: 'b', 3: 'c'}

Для этого может быть использована функция zip:
b = dict(zip((1, 2, 3, 4, 5), ('a', 'ab', 'b', 'bc', 'c')))  # b = {1: 'a', 2: 'ab',
                                                                    3: 'b', 4: 'bc', 5: 'c'}

Особенности словаря:
1. Доступ к элементам можно рассматривать, как мгновенный (чуть-чуть наврал)
2. Ключи - уникальны, обязаны быть хэшируемыми, неизменяемыми
3. Элементы неупорядочены
4. **название обозначает, что название - словарь

Классовые методы:
1. setdefault(self, key, default=None, /)  --  задаёт значение default по ключу key. Если по этому улючу уже было значение, то также возвращает предудущее значение

D = {1: 'abc', 2: ('vasya', 'petya')}
D.setdefault(3, 'ammonium')  # {1: 'abc', 2: ('vasya', 'petya'), 3: 'ammonium'}
b = D.setdefault(2, ['alex'])  # b = ('vasya', 'petya')  
                               # {1: 'abc', 2: ['alex'], 3: 'ammonium'}
D.setdefault(1)  # {1: None, 2: ['alex'], 3: 'ammonium'}


2. get(self, key, default=None, /)  --  возвращает значение по ключу key. Если не находит, возвращает default

D = {1: 'abc', 2: ('vasya', 'petya'), 3: 'ammonium'}
a = D.get(1)  # 'abc'
b = D.get(444)  # None
c = D.get(8, 'nothing')  # 'nothing'


3. items()  --  возвращает множество-подобный объект, предоставляющий отображение пар словаря

D = {1: 'lol', 'a': (1, 2), (95, 0): ['a', 'm', 'q']}
a = D.items()  # dict_items([(1, 'lol'), ('a', (1, 2)), ((95, 0), ['a', 'm', 'q'])])

dict_items можно кидать в цикл for, распаковывать, преобразовывать к другим коллекциям


4. keys()  --  возвращает множество-подобный объект, предоставляющий отображение ключей словаря

D = {1: 'lol', 'a': (1, 2), (95, 0): ['a', 'm', 'q']}
a = D.items()  # dict_keys([1, 'a', (95, 0)])

С dict_keys можно делать тоже, что и с dict_items


5. values()  --  возвращает множество-подобный объект, предоставляющий отображение значений словаря

D = {1: 'lol', 'a': (1, 2), (95, 0): ['a', 'm', 'q']}
a = D.values()  # dict_values(['lol', (1, 2), ['a', 'm', 'q']])

С dict_values можно делать тоже, что и с dict_items


6. pop(k[,d])  --  удаляет соответсвующий ключ k и возвращает значение по этому ключу. Если ключа не находит возвращает d. Если не дано d вызывает ошибку KeyError

D = {'a': (1, 2), (95, 0): ['a', 'm', 'q']}
a = D.pop((95, 0))  # a = ['a', 'm', 'q']  D = {'a': (1, 2)}
b = D.pop(9, 'err')  # b = 'err'  D = {'a': (1, 2)}
D.pop(3, 'q')  # D = {'a': (1, 2)}
c = D.pop(10)  # KeyError: 10


7.  popitem()  --  удаляет пару из словаря и возвращает кортеж (ключ, значение). Ключи возвращаются в порядке LIFO (объясню это позже). Кидает ошибку KeyError, если словарь пустой

D = {1: 2,
     2: 3,
     3: 4}
a = D.popitem()  # (3, 4)  {1: 2, 2: 3}
D.popitem()  # (2, 3)  {1: 2}
D.popitem()  # (1, 2)  {}
D.popitem()  # KeyError: 'popitem(): dictionary is empty'


8. update([E, ]**F)  --  обновляет словарь значениями из E и F по следующим правилам:
E  --  iterable
Если передан аргумент E и имеет метод .keys(), тогда происходит: for k in E: D[k] = E[k]
Если передан аргумент E и не имеет метод .keys(), тогда происходит: for k, v in E: D[k] = v
Верхняя часть также может дополнятся: for k in F:  D[k] = F[k]

D = {}
D1 = {1: '2', 'a': 'b'}
D2 = ((5, 'c'), (6, 'm'))
D3 = {1: 2, 'a': 'q'}
D4 = [(3, 9), (4, 8)]
D.update(D1)  # {1: '2', 'a': 'b'}
D.update(D2)  # {1: '2', 'a': 'b', 5: 'c', 6: 'm'}
D.update(D3)  # {1: 2, 'a': 'q', 5: 'c', 6: 'm'}
D.update(D4, key1=4, another_key=9)  # {1: 2, 'a': 'q', 5: 'c', 6: 'm', 3: 9, 4: 8, 'key1': 4, 'another_key': 9}

9. Также возможен доступ по индексу(условно, реалзация другая) D[b]. Это равносильно D.get(b)
D = {1: 2, 'a': 'b'}
D[1]  # 2


10. copy()  --  возвращает копию словаря с новым id


11. clear()  --  очищает словарь


	Множество
Множество  --  изменямая коллекция, представляющая неупорядоченный набор уникальных элементов

В python множество представляется классами set и frozenset. set - изменяемое, frozenset - неизменяемое

Литерал множества(set):
{} где значения разделяются запятыми. Пустое множество: set()

Как создать множество
1. Литералом с 1 и больше элементов
a = {1, 2, '4'}

2. На основании другой коллекции set(col)
a = set((1, 2, 4, 5, 3, 2))

3. Пустое множество
a = set()


Особенности множества:
1. Элементы уникальны
2. Элементы обязаын быть хэшируемыми
3. Множество неупорядоченно
4. Множество неиндексированно


Классовые функции множества:
1. add(el)  --  добавляет el в множество. Если такой элемент уже присутсвует, то ничего не происходит
a = set()
a.add(9)  # {9}
a.add('abc')  # {9, 'abc'}
a.add(9)  # {9, 'abc'}


2. discard(el)  --  удаляет el из множества. Если такого не существует, то ничего не происходит
a = {1, 2, 3}
a.discard(1)  # {2, 3}
a.discard('this is not an error, ha!')  # {2, 3}


3. pop()  --  удаляет произвольный элемент из множества и возвращает его. Если множество пустое - KeyError
a = {1, 2, 3}
a.pop()  # 1
a.pop()  # 2
a.pop()  # 3
a.pop()  # KeyError: 'pop from an empty set'


4. remove(el)  --  удаляет el из множества. Если такого не существует - KeyError
a = {1, 2, 3}
a.remove(2)  # {1, 2}
a.remove(5)  # KeyError: 5


5. union(set1, ...)  --  возвращает объединение данного множества и остальных. НЕ меняет исходные множеста
a = {1, 2, 3}
b = {1, 4, 5}
c = {2, 1, 9}

a.union(b)  # {1, 2, 3, 4, 5}
set.union(a, b)  # {1, 2, 3, 4, 5}
set.union(c, a)  # {1, 2, 3, 9}
c.union(b)  # {1, 2, 4, 5, 9}
set.union(a, b, c)  # {1, 2, 3, 4, 5, 9}
a.union()  # {1, 2, 3}
set.union()  # TypeError: unbound method set.intersection() needs an argument

Примечание:
Предпочтительней set.union(...), так проще понимать, что мы объяденяем
Также можно использовать |:  a | b


6. intersection(set1, ...)  --  возвращает пересечение данного множества и остальных. НЕ меняет исходные множеста
a = {1, 2, 3}
b = {1, 4, 5}
c = {2, 1, 9}
d = {}

a.intersection(b)  # {1}
set.intersection(a, b, c)  # {1}
d.intersection(a, b, c)  # {}
set.intersection(b, c, d)  # {}
a.intersection()  # {1, 2, 3}
set.intersection()  # TypeError: unbound method set.intersection() needs an argument

Примечание:
Предпочтительней set.intersection(...), так проще понимать, что мы пересекаем
Также можно использовать &:  a & b


7. difference(set1, ...)  --  возвращает все элементы, которые есть в начальном множестве, но нет в других. НЕ меняет исходное множество
a = {1, 2, 3}
b = {2, 3, 4}
c = {3, 6, 9}

a.difference(b)  # {1}
b.difference(a)  # {4}
set.difference(b, c)  # {2, 4}
set.difference(a, b, c)  # {1}
set.difference(c, a, b)  # {9, 6}
a.difference()  # {1, 2, 3}
set.difference()  # TypeError: unbound method set.difference() needs an argument

Примечание:
Предпочтительней a.difference(...), так как разница именно из первого множества
set.difference(set1, set2, ...) равносильно set1 - set2 - ... равносильно set1.difference(set2, ...)


8. symmetric_difference(set1)  --  возвращает множество, состоящее из элементов которых нет в изначальном множестве, но есть в set1
a = {1, 2, 3}
b = {2, 3, 4}
c = {1, 3, 5}

a.symmetric_difference(b)  # {1, 4}
set.symmetric_difference(b, c)  # {1, 2, 4, 5}
{5, 6}.symmetric_difference(c)  # {1, 3}


9. update(set1, ...)  --  то же, что и union, но МЕНЯЕТ изначальное множество


10. difference_update(set1, ...)  --  то же, что и difference, но МЕНЯЕТ изначальное множество


11. intersection_update(set1, ...)  --  то же, что и intersection, но МЕНЯЕТ изначальное множество


12. symmetric_difference_update(set1)  --  то же, что и symmetric_difference, но МЕНЯЕТ изначальное множество


13. isdisjoint(set1)  --  True, если два множества не пересекаются. Иначе False
a = {1, 2, 3}
b = {4, 5, 6}

a.isdisjoint(b)  # True
set.isdisjoint(b, {4, 7, 8})  # False
{8, 9, 10}.isdisjoint({5, 6, 7})  # True


14. issubset(set1)  --  True, если начальное множество является подмножеством set1. Иначе False
a = {1, 2}
b = {1, 2, 3}

a.issubset(b)  # True
b.issubset(a)  # False
{1, 2}.issubset(a)  # True


15. issuperset(set1)  --  True, если начальное множество является надмножеством set1. Иначе False
a = {1, 2}
b = {1, 2, 3}

a.issuperset(b)  # False
b.issuperset(a)  # True
{1, 2}.issuperset(a)  # True


16. clear()  --  очищает множество


17. copy()  --  возвращает копию множества с новым идентификатором


	frozenset
Это тупо неизменяемое множество. С ним можно всё, что не меняет изначальное множество


	Строки
Строка  --  неизменяемая последовательность, представляющая текстовые данные

Строки в python представляются классом str

Литералы строк:
''
""

Можно использовать, как двойные, так и одинарные ковычки, разницы нет


Как можно создать строку:
1. Литералом
a = 'abc'
b = "I'm a person"

2. Из другого объекта
a = str(1)
b = str(True)
c = str((1, 2))


Классовые методы:
1. count(sub[, start[, end]])  --  считает, сколько непересекающихся строк sub в срезе [start:end]
a = 'abcabc111111'
a.count('1')  # 6
a.count('abc')  # 2
a.count('bc', 2)  # 1
a.count('11', 6, 11)  # 2


2. find(sub[, start[, end]])  --  возвращает индекс первой строки sub в срезе [start:end]. Если не находит, возвращает -1

sentence = 'Она продает ракушки на берегу моря. Товары, которые она продает, безусловно, ракушки.'
sentence.find('ракушки')  # 10
sentence.find('ракушки',0,9)  # -1
sentence.find('р',5,10)  # 8


3. index(sub[, start[, end]])  --  аналогично find, но если не находит ValueError
sentence = 'Она продает ракушки на берегу моря. Товары, которые она продает, безусловно, ракушки.'
sentence.index('ракушки')  # 10
sentence.index('ракушки',0,9)  # ValueError: substring not found
sentence.index('р',5,10)  # 8


4. isdigit(self, /)  --  возвращает правду, если строка является целым числом и содержит как минимум 1 символ
''.isdecimal()  # False
'0'.isdecimal()  # True
'1'.isdecimal()  # True
'1000'.isdecimal()  # True
'1.1'.isdecimal()  # False
'1 000'.isdecimal()  # False
'a'.isdecimal()  # False


5. replace(self, old, new, count=-1, /)  --  возвращает новую строку, в которой все подстроки old заменены на новые подстроки new. Заменяет не больше, чем count подстрок. Если count = -1 заменяет все подстроки
my_str = 'barbarian'
my_str = my_str.replace('bar', 'mur')  # 'murmurian'
my_str = my_str.replace('mur', 'bur', 1)  # 'burmurian'
'1111111'.replace('1', '22')  # '22222222222222'
'1111111'.replace('111', '3')  # '331'


Остальное мы рассмотрим в отдельной теме

	git
Git  --  это распределённая система управления версиями

Нам она понадобится для коллоборации кода и текста. То есть чтобы мы могли передавать информацию в общее хранилище и это всё без флешек

Как установить git: скачать установщик и установить

Как работать с git:
1. Через консоль git
2. Через sublime text 3
3. Через PyCharm
4. Через консоль windows - cmd

Мы будем использовать 4 вариант. Ну по-крайней мере я буду учить тебя именно ему

Для начала нам понадобиться сам проект. Его можно получить двумя способами:
1. Создать новый и настроить всё от руки
2. Клонировать его с общего репозитория

Мы рассмотрим 2 варианта

В обоих случаях нам понадобится папка с проектом поэтому я тебе советую создать в документах папку GitHub и там создать папку Programming - сам проект

Затем необходимо перейти в неё в консоли

Рассмотрим команды git:
1. clone

Скачивает репозиторий с инета или ещё откуда

Использование:
git clone [<options>] [--] <repo> [<dir>]

<options>  --  доп настройки, которых мы не коснёмся
<repo>  --  ссылка на репозиторий
<dir>  --  куда его скачать. Если не указано в текущую папку

2. status

Выводит текущий статус данного проекта. То есть какие изменения ты внесла, что добавила к commit-у и т.д.

Использование:
git status [<options>…​] [--] [<pathspec>…​]

<options>  --  доп. настройки
<pathspec>  --  спецификации пути, в которых я не шарю


options:
-s
--short
Выводят информацию о проекте кратко

-b
--branch
Показывают информации о конкретной ветке инфу об отслеживании даже в кратком формате

--long
Показывает информацию в длинном формате. Используется по дефолту

-u[<mode>]
--untracked-files[=<mode>]
Показывать или нет файлы, которые не были добалены в commit
<mode>  --  доп. настройки
no - не показывать
normal - показывать файлы и директории не добавленные в commit
all - также показывать каждый файл отдельно в неотслеженных директориях

--column[=<options>]
--no-column
Показывать неостлеженные файлы и директории в колоннах


Чё выводится:
' ' = unmodified
M = modified
A = added
D = deleted
R = renamed
C = copied
U = updated but unmerged
? - untracked
! - ignored

3. log
Показывает лог коммитов

Использование
git log [<options>] [<revision range>] [[--] <path>…​]

<options>  --  настройки
<revision range>  --  показывает коммиты в этой области
<path>  --  путь к репозиторию

Чтобы выйти из режима log нужно нажать q
Чтобы листать можно использовать стрелочки вверх вниз и enter только вниз

options:
--full-diff
Показывает полную разницу, а не только изменения

--log-size
Включает в каждый коммит строку с размером коммита


4. add
Добавляет файлы в коммит

Использование:
git add [--verbose | -v] [--dry-run | -n] [--force | -f] [--interactive | -i] [--patch | -p]
          [--edit | -e] [--[no-]all | --[no-]ignore-removal | [--update | -u]]
          [--intent-to-add | -N] [--refresh] [--ignore-errors] [--ignore-missing] [--renormalize]
          [--chmod=(+|-)x] [--pathspec-from-file=<file> [--pathspec-file-nul]]
          [--] [<pathspec>…​]

-n
--dry-run
По факту не добавляет файлы, а просто показывает существуют ли они и будут ли добалены или проигнорированы

-f
--force
Позволяет добавлять даже проигнорирвоанные файлы

-A
--all
Добавляет сразу все файлы в коммит

<pathpsec>  --  путь к файлам, которые будут добавлены. Это может быть как уникальный файл, так и папка

5. commit
Делает коммит всех добавленных файлов. То есть собирает указанные тобой локальные изменения и сохраняет их в историю

Использование:
git commit [-a | --interactive | --patch] [-s] [-v] [-u<mode>] [--amend]
           [--dry-run] [(-c | -C | --fixup | --squash) <commit>]
           [-F <file> | -m <msg>] [--reset-author] [--allow-empty]
           [--allow-empty-message] [--no-verify] [-e] [--author=<author>]
           [--date=<date>] [--cleanup=<mode>] [--[no-]status]
           [-i | -o] [--pathspec-from-file=<file> [--pathspec-file-nul]]
           [-S[<keyid>]] [--] [<pathspec>…​]

-m <msg>
Позволяет дописать сообщение к коммиту. Может быть использовано несколько раз
<msg> - сообщение. Желательно в двойных ковычках

6. push
Кидает накопившиеся коммиты в общий репозиторий

Использование:
git push [--all | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack=<git-receive-pack>]
           [--repo=<repository>] [-f | --force] [-d | --delete] [--prune] [-v | --verbose]
           [-u | --set-upstream] [-o <string> | --push-option=<string>]
           [--[no-]signed|--signed=(true|false|if-asked)]
           [--force-with-lease[=<refname>[:<expect>]] [--force-if-includes]]
           [--no-verify] [<repository> [<refspec>…​]]
-u
--set-upstream
Задаёт поток. Вспоминай лекцию

<repository>  --  конкретный репозиторий

7. pull
Перетягивает коммиты, которые лежат в общем репозитории в локальный

Использование:
git pull [<options>] [<repository> [<refspec>…​]]

<options>  --  настройки
<repository>  --  репозиторий

8. init
Создаёт пустой git репозиторий или перезапускает имеющийся

git init [-q | --quiet] [--bare] [--template=<template_directory>]
          [--separate-git-dir <git dir>] [--object-format=<format>]
          [-b <branch-name> | --initial-branch=<branch-name>]
          [--shared[=<permissions>]] [directory]

9. remote
Менеджит набор репозиториев

Использование:
Вариаций куча, но мы рассмотрим единственную
git remote add [-t <branch>] [-m <master>] [-f] [--[no-]tags] [--mirror=(fetch|push)] <name> <url>

<name>  --  название репозитория
<url>  --  ссылка на общий репозиторий

quotepath = false
прописать в config



	Выражения генераторы(comprehension expression)
1.1. Что и зачем:
Генераторы выражений предназначены для компактного и удобного способа генерации коллекций элементов, а также преобразования одного типа коллекций в другой

В процессе генерации или преобразования возможно применение условий и модификация элементов

Генераторы выражений являются синтаксическим сахаром и не решают задач, которые нельзя было бы решить без их использования

1.2. Преимущества генераторов:
Более короткий и удобный синтаксис, чем генерация в обычном цикле

Более понятный и читаемый синтаксис чем функциональный аналог сочетающий одновременное применение функций map(), filter() и lambda

В целом: быстрее набирать, легче читать, особенно когда подобных операций много в коде

1.3. Классификация и особенности:
Выражение-генератор (generator expression) — выражение в круглых скобках которое выдает создает на каждой итерации новый элемент по правилам

Генератор коллекции — обобщенное название для генератора списка (list comprehension), генератора словаря (dictionary comprehension) и генератора множества (set comprehension)

Смотри рисунок 17


2. Синтаксис

Для начала взгляни на общий синтаксис

Смотри рисунок 18

Ввод — это итератор — это может быть функция-генератор, выражение-генератор, коллекция — любой объект поддерживающий итерацию по нему

Условие — это фильтр при выполнении которого элемент пойдет в финальное выражение, если элемент ему не удовлетворяет, он будет пропущен

Финальное выражение — преобразование каждого выбранного элемента перед его выводом или просто вывод без изменений

2.1. Базовый синтаксис

list_a = [-2, -1, 0, 1, 2, 3, 4, 5]    # Пусть у нас есть исходный список
list_b = [x for x in list_a]           # Создадим новый список используя генератор списка
print(list_b)                          # [-2, -1, 0, 1, 2, 3, 4, 5]
print(list_a is list_b)                # False - это разные объекты!

2.2. Добавляем условие для фильтрации
Важно: Условие проверяется на каждой итерации, и только элементы ему удовлетворяющие идут в обработку в выражении

Теперь мы берём в список только чётные элементы

# if x % 2 == 0 - остаток от деления на 2 равен нулю - число четное
list_a = [-2, -1, 0, 1, 2, 3, 4, 5] 
list_b = [x for x in list_a if x % 2 == 0]
print(list_b)   # [-2, 0, 2, 4]

Можно использовать несколько условий:
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
list_b = [x for x in list_a if x % 2 == 0 and x > 0]
# берем те x, которые одновременно четные и больше нуля
print(list_b)   # [2, 4]

2.3. Добавляем обработку элемента в выражении
Важно: Выражение выполняется независимо на каждой итерации, обрабатывая каждый элемент индивидуально

Посчитаем только квадраты
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
list_b = [x**2 for x in list_a]
print(list_b)   # [4, 1, 0, 1, 4, 9, 16, 25]

Посчитаем длины строк
list_a = ['a', 'abc', 'abcde']
list_b = [len(x) for x in list_a]
print(list_b)   # [1, 3, 5]

2.4. Ветвление выражения
Обрати внимание: Мы можем использовать (начиная с Python 2.5) в выражении конструкцию if-else для ветвления финального выражения

В таком случае:

Условия ветвления пишутся не после, а перед итератором

В данном случае if-else это не фильтр перед выполнением выражения, а ветвление самого выражения, то есть переменная уже прошла фильтр, но в зависимости от условия может быть обработана по-разному!

list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
list_b = [x if x < 0 else x**2 for x in list_a]
# Если x-отрицательное - берем x, в остальных случаях - берем квадрат x
print(list_b)   # [-2, -1, 0, 1, 4, 9, 16, 25]

Никто не запрещает комбинировать фильтрацию и ветвление:

list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
list_b = [x**3 if x < 0 else x**2 for x in list_a if x % 2 == 0]
# вначале фильтр пропускает в выражение только четные значения
# после этого ветвление в выражении для отрицательных возводит в куб, а для остальных в квадрат
print(list_b)   # [-8, 0, 4, 16]

Можно было бы использовать цикл:
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
list_b = []
for x in list_a:
    if x % 2 == 0:
        if x < 0:
            list_b.append(x ** 3)
        else:
            list_b.append(x ** 2)
print(list_b)   # [-8, 0, 4, 16]

Улучшаем читаемость:
numbers = range(10)

# Before
squared_evens = [n ** 2 for n in numbers if n % 2 == 0]

# After
squared_evens = [
    n ** 2
    for n in numbers
    if n % 2 == 0
]


3. Аналоги в виде цикла for и в виде функций
Задача: сделаем из списка чисел список квадратов четных чисел

3.1. Решение с помощью генератора списка:
numbers = range(10)
squared_evens = [n ** 2 for n in numbers if n % 2 == 0]
print(squared_evens)   # [0, 4, 16, 36, 64]

3.2. Решение c помощью цикла for:
Важно: Каждый генератор выражений можно переписать в виде цикла for, но не каждый цикл for можно представить в виде такого выражения.

numbers = range(10)
squared_evens = []
for n in numbers:
    if n % 2 == 0:
        squared_evens.append(n ** 2)
print(squared_evens)   # [0, 4, 16, 36, 64]

3.3. Решение с помощью функций:
numbers = range(10)
squared_evens = map(lambda n: n ** 2, filter(lambda n: n % 2 == 0, numbers))
print(squared_evens)         # <map object at 0x7f661e5dba20>
print(list(squared_evens))   # [0, 4, 16, 36, 64]
# Примечание: в Python 2 в переменной squared_evens окажется сразу список, а в Python 3 «map object», который мы превращаем в список с помощью list()


4. Выражения-генераторы
Основное их отличие от генераторов коллекций в том, что они выдают элемент по-одному, не загружая в память сразу всю коллекцию

Особенности выражений-генераторов:

4.1. Генаратор нельзя писать без скобок — это синтаксическая ошибка
# my_gen = i for i in list_a      # SyntaxError: invalid syntax

4.2. При передаче в функцию дополнительные скобки необязательны
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_sum = sum(i for i in list_a)
# my_sum = sum((i for i in list_a))  # так тоже можно
print(my_sum)   # 12

4.3. Нельзя получить длину функцией len()
# my_len = len(i for i in list_a)  # TypeError: object of type 'generator' has no len()

4.4. Нельзя распечатать элементы функцией print()
print(my_gen)   # <generator object <genexpr> at 0x7f162db32af0>

4.5. Обрати внимание, что после прохождения по выражению-генератору оно остается пустым!
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_gen = (i for i in list_a)
print(sum(my_gen))  # 12
print(sum(my_gen))  # 0

4.6. Выражение-генератор может быть бесконечным
import itertools
inf_gen = (x for x in itertools.count())  # бесконечный генератор от 0 to бесконечности!

4.7. К выражению-генератору не применимы срезы
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_gen = (i for i in list_a)
my_gen_sliced = my_gen[1:3]
# TypeError: 'generator' object is not subscriptable

4.8. Из генератора легко получать нужную коллекцию

5. Генерация стандартных коллекций

5.1. Создание коллекций из выражения-генератора

Передачей готового выражения-генератора присвоенного переменной в функцию создания коллекции.

list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_gen = (i for i in list_a)   # выражение-генератор
my_list = list(my_gen) 
print(my_list)          # [-2, -1, 0, 1, 2, 3, 4, 5]

Написание выражения-генератора сразу внутри скобок вызываемой функции создания коллекции.

list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_list = list(i for i in list_a)
print(my_list)          # [-2, -1, 0, 1, 2, 3, 4, 5]

Пример выше справедлив и для кортежей, множеств и frozenset

5.2. Специальный синтаксис генераторов коллекций
Обрати внимание, что для генерации множества и словаря используются одинаковые скобки, разница в том, что у словаря указывается двойной элемент ключ: значение

Генератор списка (list comprehension)

list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_list = [i for i in list_a]
print(my_list)          # [-2, -1, 0, 1, 2, 3, 4, 5]

Не пиши круглые скобки в квадратных!

list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_list = [(i for i in list_a)]
print(my_list)          # [<generator object <genexpr> at 0x7fb81103bf68>]

Генератор множества (set comprehension)

list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_set= {i for i in list_a}
print(my_set)       # {0, 1, 2, 3, 4, 5, -1, -2} - порядок случаен

Генератор словаря (dictionary comprehension)
переворачивание словаря

dict_abc = {'a': 1, 'b': 2, 'c': 3, 'd': 3}
dict_123 = {v: k for k, v in dict_abc.items()}
print(dict_123)  # {1: 'a', 2: 'b', 3: 'd'}
                 # Обратите внимание, мы потеряли "с"! Так как значения были одинаковы, 
                 # то когда они стали ключами, только последнее значение сохранилось.

Словарь из списка:
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
dict_a = {x: x**2 for x in list_a}
print(dict_a)   # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, -2: 4, -1: 1, 5: 25}

Важно! Такой синтаксис создания словаря работает только в фигурных скобках, выражение-генератор так создать нельзя, для этого используется немного другой синтаксис:
# dict_gen = (x: x**2 for x in list_a)      # SyntaxError: invalid syntax
dict_gen = ((x, x ** 2) for x in list_a)    # Корректный вариант генератора-выражения для словаря
# dict_a = dict(x: x**2 for x in list_a)    # SyntaxError: invalid syntax
dict_a = dict((x, x ** 2) for x in list_a)  # Корректный вариант синтаксиса от @longclaps

5.3. Генерация строк

Для создания строки вместо синтаксиса выражений-генераторов используется метод строки .join(), которому в качестве аргументов можно передать выражение генератор.
Обрати внимание: элементы коллекции для объединения в строку должны быть строками!

list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
# используем генератор прямо в .join() одновременно приводя элементы к строковому типу
my_str = ''.join(str(x) for x in list_a)
print(my_str)  # -2-1012345

6. Периодичность и частичный перебор

6.1. Работа с enumerate()
enumerate  --  итерируемый объект, который построен следующим образом: сначало идёт индекс, а затем сам элемент. Он бывает полезен

for i, x in enumerate(iterable)
i  --  индекс
x  --  элемент

list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
list_d = [(i, x) for i, x in enumerate(list_a)]
print(list_d)   # [(0, -2), (1, -1), (2, 0), (3, 1), (4, 2), (5, 3), (6, 4), (7, 5)]

Выберем в генераторе списка каждый третий элемент из исходного списка:
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
list_e = [x for i, x in enumerate(list_a, 1) if i % 3 == 0]
print(list_e)   # [0, 3]


	Возможны два варианта вызова функции enumerate():
enumerate(iterator) без второго параметра считает с 0.
enumerate(iterator, start) — начинает считать с значения start. Удобно, например, если нам надо считать с 1, а не 0.

enumerate() возвращает кортеж из порядкового номера и значения текущего элемента итератора. Кортеж в выражении-генераторе результате можно получить двумя способами:
(i, j) for i, j in enumerate(iterator) — скобки в первой паре нужны!
pair for pair in enumerate(mylist) — мы работаем сразу с парой

Индексы считаются для всех обработанных элементов, без учета прошли они в дальнейшем условие или нет!

first_ten_even = [(i, x) for i, x in enumerate(range(10)) if x % 2 == 0]
print(first_ten_even)   # [(0, 0), (2, 2), (4, 4), (6, 6), (8, 8)]

Функция enumerate() не обращается к каким-то внутренним атрибутам коллекции, а просто реализует счетчик обработанных элементов, поэтому ничего не мешает ее использовать для неупорядоченных коллекций не имеющих индексации

Если мы ограничиваем количество элементов включенных в результат по enumerate() счетчику (например if i < 10), то итератор будет все равно обработан целиком, что в случае огромной коллекции будет очень ресурс-затратно

6.2. Перебор части итерируемого
islice() из itertools
import itertools
first_ten = (itertools.islice((x for x in range(1000000000) if x % 2 == 0), 10))
print(list(first_ten))  # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

7. Вложенные циклы и генераторы

7.1. Вложенные циклы
В результате генерации получаем одномерную структуру

Важно! При работае с вложенными циклами внутри генератора выражений порядок следования инструкций for in будет такой же (слева-направо), как и в аналогичном решении без генератора, только на циклах (сверху-вниз)! Тоже справедливо и при более глубоких уровнях вложенности

7.1.1. Вложенные циклы for где циклы идут по независимым итераторам
Общий синтаксис: [expression for x in iter1 for y in iter2]
Применение: генерируем одномерную структуру, используя данные из двух итераторов

Создадим словарь, используя кортежи координат как ключи, заполнив для начала его значения нулями:

rows = 1, 2, 3
cols = 'a', 'b'
my_dict = {(col, row): 0 for row in rows for col in cols}
print(my_dict)  # {('a', 1): 0, ('b', 2): 0, ('b', 3): 0, ('b', 1): 0, ('a', 3): 0, ('a', 2): 0}

Тоже можно сделать и с дополнительными условиями-фильтрами в каждом цикле:

rows = 1, 2, 3, -4, -5
cols = 'a', 'b', 'abc'
# Для наглядности разнесем на несколько строк
my_dict = {
    (col, row): 0  # каждый элемент состоит из ключа-кортежа и нулевого знаечния
    for row in rows if row > 0   # Только положительные значения
    for col in cols if len(col) == 1  # Только односимвольные
    }
print(my_dict)  # {('a', 1): 0, ('b', 2): 0, ('b', 3): 0, ('b', 1): 0, ('a', 3): 0, ('a', 2): 0}


7.1.2. Вложенные циклы for где внутренний цикл идет по результату внешнего цикла
Общий синтаксис: [expression for x in iterator for y in x]
Применение: Стандартный подход, когда нам надо обходить двумерную структуру данных, превращая ее в «плоскую» одномерную. В данном случае, мы во внешнем цикле проходим по строкам, а во внутреннем по элементам каждой строки нашей двумерной структуры

Допустим у нас есть двумерная матрица  --  список списков. И мы желаем преобразовать ее в плоский одномерный список

matrix = [[0, 1, 2, 3],
          [10, 11, 12, 13],
          [20, 21, 22, 23]]

# Решение с помощью генератора списка:
flattened = [n for row in matrix for n in row]
print(flattened)    # [0, 1, 2, 3, 10, 11, 12, 13, 20, 21, 22, 23]

То же с циклами:
flattened = []
for row in matrix:
    for n in row:
        flattened.append(n)
print(flattened)

Изящные решения:
import itertools
flattened = list(itertools.chain.from_iterable(matrix))
# Данный подход намного быстрее генератора списков 
# и рекомендован к использованию для подобных задач

flattened = sum(a, [])
# sum(a, []) имеет квадратическую сложность(O(n^2)) 
# и потому совсем не рекомендуется к использованию для таких целей

7.2. Вложенные генераторы
Вложенными могут быть не только циклы for внутри выражения-генератора, но и сами генераторы.
Такой подход применяется когда нам надо строить двумерную структуру

Важно!: В отличии от примеров выше с вложенными циклами, для вложенных генераторов, вначале обрабатывается внешний генератор, потом внутренний, то есть порядок идет справа-налево

7.2.1. — Вложенный генератор внутри генератора — двумерная из двух одномерных
Общий синтаксис: [[expression for y in iter2] for x in iter1]
Применение: генерируем двумерную структуру, используя данные из двух одномерных итераторов

Для примера создадим матрицу из 5 столбцов и 3 строк и заполним ее нулями:

w, h = 5, 3  # зададим ширину и высотку матрицы
matrix = [[0 for x in range(w)] for y in range(h)]
print(matrix)   # [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]

С помощью циклов(обрати внимание на порядок циклов):
matrix = []
for y in range(h):
    new_row = []
    for x in range(w):
        new_row.append(0)
    matrix.append(new_row)
print(matrix)   # [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]

После создания можно работать с матрицей, как с двумерным объектом:
# теперь можно добавлять значения по координатам (координаты - индексы в списке списков)
matrix[0][0] = 1
matrix[1][3] = 3
print(matrix)   # [[1, 0, 0, 0, 0], [0, 0, 0, 3, 0], [0, 0, 0, 0, 0]]

# Получаем значение по произвольным координатам
x, y = 1, 3
print(matrix[x][y])  # 3

7.2.2. — Вложенный генератор внутри генератора — двумерная из двумерной
Общий синтаксис: [[expression for y in x] for x in iterator]
Применение: Обходим двумерную структуру данных, сохраняя результат в другую двумерную структуру

Возьмем матрицу:

matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]

Возведем каждый элемент матрицы в квадрат:

squared = [[cell**2 for cell in row] for row in matrix]
print(squared)    # [[1, 4, 9, 16], [25, 36, 49, 64], [81, 100, 121, 144]]

Вложенные циклы:
squared = []
for row in matrix:
    new_row = []
    for cell in row:
        new_row.append(cell**2)
    squared.append(new_row)
print(squared)    # [[1, 4, 9, 16], [25, 36, 49, 64], [81, 100, 121, 144]]

Обобщим вышеперечисленные варианты:
Смотри рисунок 19

7.3. — Генератор итерирующийся по генератору
Допустим у нас есть два таких генератора списков:
list_a = [x for x in range(-2, 4)]    # Так сделано для дальнейшего примера синтаксиса, 
                                      # конечно в подобной задаче досточно только range(-2, 4)
list_b = [x**2 for x in list_a]

Тоже самое можно записать и в одно выражение, подставив вместо list_a его генератор списка:
list_c = [x**2 for x in [x for x in range(-2, 4)]]
print(list_c)  # [4, 1, 0, 1, 4, 9]

Преимущество от комбинирования генераторов на примере сложной функции f(x) = u(v(x)):
list_c = [t + t ** 2  for t in (x ** 3 + x ** 4 for x in range(-2, 4))]

8. Использование range()

Особенности функции range():

Наиболее часто функция range() применяется для запуска цикла for нужное количество раз. Например, смотри генерацию матрицы в примерах выше

В Python 3 range() возвращает генератор, который при каждом к нему обращении выдает очередной элемент

Исполльзуемые параметры аналогичны таковым в срезах (кроме первого примера с одним параметром):

range(stop) — в данном случае с 0 до stop-1;
range(start, stop) — Аналогично примеру выше, но можно задать начало отличное от нуля, можно и отрицательное;
range(start, stop, step) — Добавляем параметр шага, который может быть отрицательным, тогда перебор в обратном порядке

В Python 2 были 2 функции:

range(...) которая аналогична выражению list(range(...)) в Python 3 — то есть она выдавала не итератор, а сразу готовый список. То есть все проблемы возможной нехватки памяти, описанные в разделе 4 актуальны, и использовать ее в Python 2 надо очень аккуратно!
xrange(...) — которая работала аналогично range(...) в Python 3 и из 3 версии была исключена.

Примеры использования:

print(list(range(5)))           # [0, 1, 2, 3, 4]
print(list(range(-2, 5)))       # [-2, -1, 0, 1, 2, 3, 4]
print(list(range(5, -2, -2)))   # [5, 3, 1, -1]

9. Приложение 1. Дополнительные примеры

9.1. Последовательный проход по нескольким спискам

import itertools
l1 = [1,2,3]
l2 = [10,20,30]
result = [l*2 for l in itertools.chain(l1, l2)]
print(result)   # [2, 4, 6, 20, 40, 60]

9.2. Транспозиция матрицы
(Преобразование матрицы, когда строки меняются местами со столбцами)

Возьмем матрицу

matrix = [[1, 2, 3, 4],
          [5, 6, 7, 8],
          [9, 10, 11, 12]]

Сделаем ее транспозицию с помощью генератора выражений:

transposed = [[row[i] for row in matrix] for i in range(len(matrix[0]))]
print(transposed)  # [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]

С помощью циклов:
transposed = []
for i in range(len(matrix[0])):
    new_row = []
    for row in matrix:
        new_row.append(row[i])
    transposed.append(new_row)
print(transposed)  # [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]

И немного черной магии:
transposed = list(map(list, zip(*matrix)))
print(transposed)  # [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]

9.3 Задача выбора только рабочих дней

# Формируем список дней от 1 до 31 с которым будем работать
days = [d for d in range(1, 32)]

# Делим список дней на недели
weeks = [days[i:i+7] for i in range(0, len(days), 7)]
print(weeks)   # [[1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12, 13, 14], [15, 16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28], [29, 30, 31]]

# Выбираем в каждой неделе только первые 5 рабочих дней, отбрасывая остальные
work_weeks = [week[0:5] for week in weeks]
print(work_weeks)   # [[1, 2, 3, 4, 5], [8, 9, 10, 11, 12], [15, 16, 17, 18, 19], [22, 23, 24, 25, 26], [29, 30, 31]]

# Если нужно одним списком дней - можно объединить
wdays = [item for sublist in work_weeks for item in sublist]
print(wdays)   # [1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 15, 16, 17, 18, 19, 22, 23, 24, 25, 26, 29, 30, 31]

Можно убрать выходные еще более изящно, используя только индексы:
# Формируем список дней от 1 до 31 с которым будем работать
days = [d for d in range(1, 32)]

wdays6 = [wd for (i, wd) in enumerate(days, 1) if i % 7 != 0]  # Удаляем каждый 7-й день
# Удаляем каждый 6 день в оставшихся после первого удаления:
wdays5 = [wd for (i, wd) in enumerate(wdays6, 1) if i % 6 != 0]

print(wdays5)
# [1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 15, 16, 17, 18, 19, 22, 23, 24, 25, 26, 29, 30, 31]

# Обратите внимание, что просто объединить два условия в одном if не получится,
# как минимум потому, что 12-й день делится на 6, но не выпадает на последний 2 дня недели!

# Шикарное короткое решение:
days = [d + 1 for d in range(31) if d % 7 < 5]


	Работа с модулями
1. Способы подключить модуль:

Вариант 1
import название

Вариант 2
from название import *

Вариант 3
from название import название1, название2, ...

Вариант 4
import название as новое_название

Вариант 5
from название import название1 as новое_название1, название2 as новое_название2, ...

В чём разница:
1. Когда мы подключаем модуль с помощью import мы не вываливаем всё пространство имён в программу. Чтобы обратиться к его содержимому нужно будет использовать следующую схему:
название.что_то

2. Когда мы используем from, то мы вываливаем то, что нам нужно из модуля прямо в программу. Если так делать много, образуется свалка в единой программе. В данном слцчае мы сможем обращаться к содержимому модулю просто:
что_то



	Модуль collections
Модуль, предоставляющий ещё коллекции

	Counter
Словаре-подобная коллекция. Содержит неизменяемые элементы в виде элемент: колличество

Как создать:
1. На основе другой коллекции:
import collections
counter = collections.Counter(collection)  # collection  --  коллекция, содержащая неизменяемые элементы

2. Заполнив пустой Counter:
import collections
c = collections.Counter()
for word in ['spam', 'egg', 'spam', 'counter', 'counter', 'counter']:
    c[word] += 1

3. Инициализировав Counter:
import collections
c = collections.Counter(a=4, b=2, c=0, d=-2)

Что можно делать с коллекцией:
1. Функция elements()  --  возвращает список элементов в лексикографическом порядке
from collections import Counter
c = Counter(a=4, b=2, c=0, d=-2)
list(c.elements())  # ['a', 'a', 'a', 'a', 'b', 'b']

2. Функция most_common([n])  --  возвращает n наиболее часто встречающихся элементов, в порядке убывания встречаемости. Если n не указано, возвращаются все элементы
from collections import Counter
Counter('abracadabra').most_common(3)  # [('a', 5), ('r', 2), ('b', 2)]

3. Функция subtract([iterable-or-mapping])  --  вычитание
from collections import Collections

c = Counter(a=4, b=2, c=0, d=-2)
d = Counter(a=1, b=2, c=3, d=4)
c.subtract(d)  # Counter({'a': 3, 'b': 0, 'c': -3, 'd': -6})

Наиболее часто употребляемые шаблоны для работы с Counter:

sum(c.values()) - общее количество
c.clear() - очистить счётчик
list(c) - список уникальных элементов
set(c) - преобразовать в множество
dict(c) - преобразовать в словарь
c.most_common()[:-n:-1] - n наименее часто встречающихся элементов
c += Counter() - удалить элементы, встречающиеся менее одного раза

Counter также поддерживает сложение, вычитание, пересечение и объединение:
from collections import Counter

c = Counter(a=3, b=1)
d = Counter(a=1, b=2)
c + d  # Counter({'a': 4, 'b': 3})
c - d  # Counter({'a': 2})
c & d  # Counter({'a': 1, 'b': 1})
c | d  # Counter({'a': 3, 'b': 2})

Нахрена:
Без понятия. В python обожают синтаксический сахар Но в некоторых задачах очень уменьшает количество кода. Например даётся текст и нужно вывести самые частовстречающиеся слова:

text = ...
for old_char in '.', ',', '!', '?', ' "', '" ', " '", "' ":
	text = text.replace(old_char + " ", ' ')
for old_char in ' "', '\n', " '":
	text = text.replace(old_char, ' ')

words = Counter(map(lambda x: x.lower(), text.split(' ')))

print(words.most_common(5))

А ведь без Counter-а пришлось бы переписать код следующим образом:

text = ...

for old_char in '.', ',', '!', '?', ' "', '" ', " '", "' ":
	text = text.replace(old_char + " ", ' ')
for old_char in ' "', '\n', " '":
	text = text.replace(old_char, ' ')

words = Counter(map(lambda x: x.lower(), text.split(' ')))

print(words.most_common(5))


for old_char in '.', ',', '!', '?':
	text = text.replace(old_char, '')

words = list(map(lambda x: x.lower(), text.split(' ')))
just_words = set(words)
count_word = []

for word in just_words:
	count_word.append((words.count(word), word))

count_word.sort(reverse=True)

print(list(map(lambda x: tuple(reversed(x)), count_word[:5])))

Работающий код в папке full code в папке Counter Examples файле example1.py


	deque
collections.deque(iterable, [maxlen]) - создаёт очередь из итерируемого объекта с максимальной длиной maxlen. Очереди очень похожи на списки, за исключением того, что добавлять и удалять элементы можно либо справа, либо слева

Методы, определённые в deque:

1. append(x) - добавляет x в конец

2. appendleft(x) - добавляет x в начало

3. clear() - очищает очередь

4. count(x) - количество элементов, равных x

5. extend(iterable) - добавляет в конец все элементы iterable

6. extendleft(iterable) - добавляет в начало все элементы iterable (начиная с последнего элемента iterable)

7. pop() - удаляет и возвращает последний элемент очереди

8. popleft() - удаляет и возвращает первый элемент очереди

9 remove(value) - удаляет первое вхождение value

10. reverse() - разворачивает очередь

11. rotate(n) - последовательно переносит n элементов из конца в начало (если n отрицательно, то с начала в конец)

	defaultdict
defaultdict ничем не отличается от обычного словаря за исключением того, что по умолчанию всегда вызывается функция, возвращающая значение:

import collections
defdict = collections.defaultdict(list)
print(defdict)  # defaultdict(<class 'list'>, {})
for i in range(5):
    defdict[i].append(i)

print(defdict)  # defaultdict(<class 'list'>, {0: [0], 1: [1], 2: [2], 3: [3], 4: [4]})

То есть он для каждого элемента применил функцию list, перед тем, как добавлять его в словарь

	OrderedDict
OrderedDict - ещё один похожий на словарь объект, но он помнит порядок, в котором ему были даны ключи

Методы:

1. popitem(last=True) - удаляет последний элемент если last=True, и первый, если last=False.

2. move_to_end(key, last=True) - добавляет ключ в конец если last=True, и в начало, если last=False.

d = {'banana': 3, 'apple':4, 'pear': 1, 'orange': 2}
OrderedDict(sorted(d.items(), key=lambda t: t[0]))  # OrderedDict([('apple', 4), ('banana', 3), ('orange', 2), ('pear', 1)])
OrderedDict(sorted(d.items(), key=lambda t: t[1]))  # OrderedDict([('pear', 1), ('orange', 2), ('banana', 3), ('apple', 4)])
OrderedDict(sorted(d.items(), key=lambda t: len(t[0])))  # OrderedDict([('pear', 1), ('apple', 4), ('orange', 2), ('banana', 3)])

	namedtuple
Класс namedtuple позволяет создать тип данных, ведущий себя как кортеж, с тем дополнением, что каждому элементу присваивается имя, по которому можно в дальнейшем получать доступ:

Point = namedtuple('Point', ['x', 'y'])
p = Point(x=1, y=2)
p  # Point(x=1, y=2)
p.x  # 1
p[0]  # 1

	ChainMap
ChainMap – это класс, который дает возможность объединить несколько сопоставлений вместе таким образом, чтобы они стали единым целым. Если вы обратитесь к документации, то увидите, что данный класс принимает **maps*

Это значит, что ChainMap будет принимать любое количество сопоставлений или словарей и превращать их в единое обновляемое представление. Примеры лежат в full code в ChainMap Examples в example1.py и example2.py

Конечно в collections ещё что-то валяется, но мы не будем этого рассматривать в данном курсе

	itertools
Модуль itertools - сборник полезных итераторов

1. itertools.count(start=0, step=1) - бесконечная арифметическая прогрессия с первым членом start и шагом step

2. itertools.cycle(iterable) - возвращает по одному значению из последовательности, повторенной бесконечное число раз

3. itertools.repeat(elem, n=Inf) - повторяет elem n раз

4. itertools.accumulate(iterable) - аккумулирует суммы

5. accumulate([1,2,3,4,5]) --> 1 3 6 10 15

6. itertools.chain(*iterables) - возвращает по одному элементу из первого итератора, потом из второго, до тех пор, пока итераторы не кончатся

7. itertools.combinations(iterable, [r]) - комбинации длиной r из iterable без повторяющихся элементов

combinations('ABCD', 2) --> AB AC AD BC BD CD

8. itertools.combinations_with_replacement(iterable, r) - комбинации длиной r из iterable с повторяющимися элементами

combinations_with_replacement('ABCD', 2) --> AA AB AC AD BB BC BD CC CD DD

9. itertools.compress(data, selectors) - (d[0] if s[0]), (d[1] if s[1]), ...

compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F

10. itertools.dropwhile(func, iterable) - элементы iterable, начиная с первого, для которого func вернула ложь

dropwhile(lambda x: x < 5, [1,4,6,4,1]) --> 6 4 1

11. itertools.filterfalse(func, iterable) - все элементы, для которых func возвращает ложь

12. itertools.groupby(iterable, key=None) - группирует элементы по значению. Значение получается применением функции key к элементу (если аргумент key не указан, то значением является сам элемент)

Смотри full code -> groupby -> example1.py

13. itertools.islice(iterable[, start], stop[, step]) - итератор, состоящий из среза

14. itertools.permutations(iterable, r=None) - перестановки длиной r из iterable

15. itertools.product(*iterables, repeat=1) - аналог вложенных циклов

product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy

16. itertools.starmap(function, iterable) - применяет функцию к каждому элементу последовательности (каждый элемент распаковывается)

starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000

17. itertools.takewhile(func, iterable) - элементы до тех пор, пока func возвращает истину

takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4

18. itertools.tee(iterable, n=2) - кортеж из n итераторов

19. itertools.zip_longest(*iterables, fillvalue=None) - как встроенная функция zip, но берет самый длинный итератор, а более короткие дополняет fillvalue

zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-

















